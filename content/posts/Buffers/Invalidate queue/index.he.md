+++
Sources = [
"https://en.wikipedia.org/wiki/MESI_protocol",
"http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf",
"http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf",
"https://stackoverflow.com/questions/11105827/what-is-a-store-buffer",
"https://pages.cs.wisc.edu/~markhill/papers/primer2020_2nd_edition.pdf",
"https://github.com/paulmckrcu/perfbook",

]
tags = [

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-11"
categories = [

]
series = [

]
title = "Invalidate queue"
+++




## מבוא

בפרוטוקולי קוהרנטיות מסוג Invalidate קיימים מספר סוגי הודעות ובניהם הודעות Invalidate פשוטות:

הודעות Invalidate:
	הודעת invalidate כוללת את הכתובת הפיזית של שורת ה-cache שיש לבטל את תוקפה. כל מעבד אחר במערכת מחויב להסיר את הנתונים הרלוונטיים מה-cache שלו ולהגיב בהתאם.


הודעות Invalidate Acknowledge:
	כאשר מעבד מקבל הודעת invalidate, הוא חייב להשיב בהודעת invalidate acknowledge לאחר שהסיר את הנתונים שצוינו מה-cache שלו.


במערכות מחשוב מתקדמות, קיימים מבנים פנימיים כמו ה-store buffer, שתפקידם לאגור באופן זמני את המידע המיועד לכתיבה בזיכרון הראשי. עם זאת, מגבלות בגודל ה-store buffer מחייבות את המעבד לנהל בקפידה את השימוש בו. כאשר המעבד מבצע רצף פעולות כתיבה (stores), במיוחד אם כל אחת מהן גורמת ל-cache miss, ה-store buffer עלול להתמלא במהירות. ברגע שה-buffer מתמלא, המעבד חייב להמתין לסיום תהליך ה-invalidations, שבמהלכו מבטלים שורות cache ישנות כדי לרוקן את ה-buffer ולאפשר המשך ביצוע. מצב זה עלול להתרחש גם לאחר הפעלת מחסום זיכרון, כאשר כל פעולות ה-store הבאות תלויות בהשלמת תהליך ה-invalidations, גם אם אין החמצת cache.

כדי לשפר את ביצועי המערכת ולהפחית את זמן ההמתנה, ניתן ליישם מנגנון שבו הודעות ה-invalidations מקבלות אישור (acknowledge) מהר יותר. אחת הדרכים להשיג זאת היא שימוש בתורי invalidate acknowledge ייעודיים לכל מעבד, הנקראים invalidate queues.

עם פרוטוקול קוהרנטיות כמו MESI, כשמעבדים מקבלים הודעות invalidation של שורות cache, הם מיישמים מנגנוני invalidate queues. במנגנונים אלו, בקשות ל-invalidate מתקבלות ומזוהות על ידי המעבד שמגיב מיד באמצעות אישור (ack) על קבלתן. עם זאת, הבקשות עצמן אינן מטופלות באופן מיידי.

זמן התגובה של הודעות ה-invalidate acknowledge עשוי להתארך בשל הצורך לוודא ששורת ה-cache הרלוונטית אכן הועברה למצב invalid. תהליך זה יכול להתעכב אם ה-cache עמוס בפעולות אינטנסיביות של טעינה ואחסון נתונים, במיוחד כאשר כל הנתונים הללו נמצאים ב-cache. בנוסף, במצבים שבהם מספר רב של הודעות invalidate מגיעות בפרק זמן קצר, המעבד עלול להתקשות לעמוד בעומס, מה שעלול לעכב גם את כל שאר המעבדים במערכת.

עם זאת, אין הכרח שהמעבד יבצע את פעולת ה-invalidate באופן מיידי לפני שליחת הודעת ה-acknowledge. במקום זאת, הוא יכול להכניס את הודעת ה-invalidate לתור (invalidate queue) ולשלוח את האישור (ack) מתוך הבנה שההודעה תעובד לפני שהמעבד ישלח הודעות נוספות הקשורות לאותה שורת cache.

במערכות עם invalidate queue, המעבד יכול לשלוח את ה-invalidates acknowledge מיד עם הכנסתם לתור, מבלי להמתין לביטול בפועל של שורת ה-cache. עם זאת, כאשר המעבד מתכונן לשדר הודעות invalidate חדשות, הוא חייב לבדוק את ה-invalidate queue שלו. אם התור מכיל ערך המתאים לשורת ה-cache המדוברת, המעבד חייב להמתין עד שהכניסה לתור תעובד לפני שהוא שולח את ההודעה החדשה.

הכנסת ערך לתור ה-invalidate queue היא למעשה התחייבות מצד המעבד לעבד את אותו ערך לפני שליחת הודעות נוספות במסגרת פרוטוקול MESI הנוגעות לאותה שורת cache. בתנאים רגילים, המעבד לא יפר את ההבטחה הזו כל עוד מבני הנתונים התואמים אינם גורמים לעיכובים משמעותיים.

עם זאת, היכולת לאחסן הודעות invalidate בתור ה-invalidate queue יוצרת סיכון פוטנציאלי נוסף לשיבושים בסדר הזיכרון. הוראות מחסום זיכרון יכולות לקיים אינטראקציה עם ה-invalidate queue, כך שכאשר מעבד נתון מבצע מחסום זיכרון, הוא מסמן את כל הערכים הקיימים בתור באותו רגע, ומחייב כל פעולת קריאה (load) עוקבת להמתין עד שכל הערכים המסומנים יוחלו במלואם על ה-cache של המעבד.

באופן כללי, read memory barrier משפיע רק על תור ה-invalidate queue ואילו write memory barrier משפיע רק על ה-store buffer, בעוד שמחסום זיכרון מלא משפיע על שניהם.

המשמעות של פעולה זו היא שמחסום זיכרון קריאה מארגן את פעולות ה-loads רק על המעבד שמבצע אותו, כך שכל פעולות הקריאה שבוצעו לפני מחסום הזיכרון נראות כאילו הושלמו לפני כל פעולת קריאה עוקבת אחר המחסום. באופן דומה, מחסום זיכרון כתיבה מסדר את פעולות ה-stores רק על המעבד שמבצע אותו, כך שכל פעולות ה-stores הקודמות למחסום נראות כאילו הושלמו לפני כל פעולת store שאחריו. מחסום זיכרון מלא מארגן גם את פעולות ה-loads וגם את פעולות ה-stores, אך כמו במחסומים האחרים, הוא משפיע רק על המעבד המבצע אותו.

ה-invalidate queue דומה במבנה שלו ל-store buffer, אך הוא משתייך למערכת הזיכרון ולא למעבד עצמו. תפקידו העיקרי הוא לשמש כתור המנהל את פעולות ה-invalidate של שורות cache, ומבטיח שהן יושלמו בצורה נכונה. כאשר תהליך invalidate מתבצע בהצלחה, ה-cache יכול לקבל בעלות על שורת ה-cache המתאימה ולבצע כתיבה בה.


---


לעומת זאת, ה-load queue הוא מבנה ספקולטיבי שנמצא בתוך המעבד ומיועד לעקוב אחר פעולות קריאה (load) שמתבצעות באופן לא מסודר (out-of-order). מבנה זה מאפשר למעבד לבצע קריאות זיכרון במקביל להוראות אחרות, מבלי להמתין לסיום פעולות קודמות, וכך לנצל בצורה מיטבית את משאבי העיבוד.


לדוגמה, המצב הבא יכול להתרחש:

1. המעבד מבצע באופן ספקולטיבי פעולת קריאה (load) מהכתובת X.
2. פעולת ה-load הזו מתבצעת לאחר פעולת כ-store לכתובת Y לפי סדר ההוראות בתוכנית, אך הכתובת Y עדיין לא נפתרה במלואה, ולכן פעולת ה-store אינה מתקדמת.
3. ברגע שהכתובת Y נפתרת, מתברר שהיא זהה לכתובת X. כאשר ה-store ל-Y מתבצעת, המעבד בודק ב-loads queue כדי לראות אם קיימות פעולות load ספקולטיביות מאוחרות יותר ביחס לסדר ההוראות בתוכנית. אם הוא מוצא את פעולת ה-load ל-X (שהיא למעשה אותה כתובת כמו Y), הוא יצטרך "למעוך" את פעולות ההוראות שהתרחשו לאחריה, החל מ-load ל-X ואילך.




---



