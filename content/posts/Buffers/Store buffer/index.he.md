+++
Sources = [
"https://en.wikipedia.org/wiki/write_buffer",
"https://developer.arm.com/documentation/den0042/a/Caches",
"http://www.rdrop.com/users/paulmck/scalability/paper/whymb.2010.07.23a.pdf",
"https://en.wikipedia.org/wiki/MESI_protocol",
"https://pages.cs.wisc.edu/~markhill/papers/primer2020_2nd_edition.pdf",
"https://stackoverflow.com/questions/54876208/size-of-store-buffers-on-intel-hardware-what-exactly-is-a-store-buffer",
"https://stackoverflow.com/questions/64141366/can-a-speculatively-executed-cpu-branch-contain-opcodes-that-access-ram/64148401#64148401",
"https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf",
"https://arxiv.org/pdf/1810.04610",
"https://stackoverflow.com/questions/64141366/can-a-speculatively-executed-cpu-branch-contain-opcodes-that-access-ram/64148401#64148401",
"https://github.com/paulmckrcu/perfbook",
"https://lwn.net/Articles/252125",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-11"
categories = [

]
series = [

]
title = "Store buffer"
+++


## מבוא

המעבדים היום הרבה יותר מהירים מהזיכרון הראשי ולכן כל גישה לזיכרון יכולה לגרום לעיכוב משמעותי בביצועי המעבד ולכן מעבדים מנסים לצמצם ככל הניתן את העיכוב הזה, ולכן פותחו טכניקות שמנסות לנתק כמה שניתן את ביצועי המעבד מהזיכרון עצמו, כמו cache-ים וכל מיני סוגי buffer-ים יעודיים.

אחד ה-buffer-ים המרכזיים הוא ה-store buffer (ידוע גם כ-write buffer) והמטרה שלו היא לנתק את ביצוע הכתיבה של המעבד.

ה-store buffer מאפשר למעבד לשגר את הוראת הכתיבה ואז הוא יכול "לשכוח" מהכתיבה וכל האחריות של ביצוע הכתיבה וכל מה שכרוך בה עוברת ל-store buffer.

ה-store buffer מספק טכניקה ידועה שנעשה בה שימוש ברוב המעבדים והארכיטקטורות (כמו ARM ,x86, AMD64, PPC ועוד רבות) ולכן יש ל-store buffer כל מיני מימושים והתהגויות שונות בין הארכיטקטורות, במאמר הזה אני אתאר בצורה כללית ה-store buffer ואגע קצת בגרסאות ספציפיות.


## Store buffer

ה-store buffer הוא סוג של זיכרון ביניים המשמש לאחסון נתונים הנכתבים מה-cache לזיכרון הראשי או ל-cache הבא בהיררכיית הזיכרון.

במערכות מרובות ליבות, השימוש ב-store buffers יכול לפגוע בעקביות הרצף של הזיכרון.

ה-store buffer מאפשר ל-cache להמשיך לטפל בבקשות קריאה בזמן שהכתיבה מתבצעת ברקע, מה שמועיל במיוחד כשמדובר בזיכרון ראשי איטי. במצב זה, קריאות נוספות יכולות להתבצע מבלי להמתין לזיכרון הראשי. אם ה-store buffer מתמלא (כלומר, כל ה-slot-ים תפוסים), הכתיבה הבאה תיאלץ להמתין עד ש-slot-ים יתפנו. 

בדומה ל-cache, הוא ממוקם בין הליבה לזיכרון הראשי, ומאפשר לליבה להמשיך בביצוע ההוראה הבאה מבלי להמתין לסיום פעולת הכתיבה בזיכרון הראשי.

גם במעבדים שפועלים בסדר עיבוד פשוט, קיימת תועלת בשימוש ב-store buffer. השימוש ב-store buffer מאפשר למעבד להימנע מהשהיות שנגרמות כתוצאה מ-cache miss  במהלך פעולות כתיבה.  

בפרקטיקה, מעבדים אינם נדרשים לשמור על סדר רציף של פעולות כתיבה, בניגוד לפעולות קריאה (load), ולכן אין צורך שהכתיבות יהיו זמינות מיד. ה-store buffer מאפשר למעבד להמשיך בביצוע הוראות נוספות, מבלי להמתין לכך שהכתיבה ל-cache תושלם.

עוד דרך להבין את ההתנהגות של ה-store buffer היא להסתכל עליו כאל סוג של register renaming.

כדי לשפר את היעילות ולהפחית את העומס על המערכת, ניתן ליישם אופטימיזציה בשם "מיזוג store buffer", שמאחד כתיבות בעלות כתובות יעד עוקבות ל-entry אחד ב-buffer. פעולה זו מונעת מהכתיבות לתפוס מקומות נפרדים ב-buffer, ובכך מפחיתה את הסיכוי לעיכובים ב-pipeline של המעבד.

ה-store buffer מקבל את פרטי הכתובת, והנתונים הקשורים לפעולת הכתיבה של הליבה לזיכרון. כאשר הליבה מבצעת הוראת store, היא יכולה להכניס ל-buffer את הפרטים הרלוונטיים, כמו מיקום הכתיבה, הנתונים וגודל הטרנזקציה.

כך, הליבה לא צריכה להמתין לסיום הכתיבה בזיכרון הראשי ויכולה להמשיך בביצוע ההוראה הבאה, בעוד שה-store buffer דואג לניקוז הכתיבה אל מערכת הזיכרון.

ה-store buffer יכול לשפר את ביצועי המערכת, כיוון שהליבה לא נאלצת להמתין לסיום פעולת ה-store. למעשה, כל עוד יש מקום ב-store buffer, הוא מספק דרך להסתיר את השהיית הכתיבה. אם מספר פעולות הכתיבה נמוך או מפוזר היטב, ה-store buffer לא יתמלא. אבל, אם הליבה מייצרת כתיבות בקצב מהיר יותר מכפי שה-buffer מסוגל לנקז, הוא יתמלא ולמעשה תועלת הביצועים תצטמצם.

ה-store buffer-ים חייבים להיות קטנים יחסית, מה שעלול להוביל למצב שבו CPU שמבצע רצף כתיבות ממלא את ה-store buffer שלו (למשל, אם כל הכתיבות גורמות ל-cache miss). במצב כזה, ה-CPU נאלץ להמתין עד להשלמת פעולת ה-invalidate שתפנה מקום ב-store buffer לפני שהוא יוכל להמשיך בפעולתו. תרחיש דומה יכול להתרחש גם לאחר מחסום זיכרון, כאשר כל הכתיבות הבאות חייבות להמתין להשלמת פעולת ה-invalidate, בין אם הן גורמות להחמצת cache ובין אם לא. 

ה-cache-ים וה-store buffers נתפסים כיתרון כיוון שהם מאיצים את ביצוע התוכנית. עם זאת, הם גם מציבים אתגרים שאין בליבה ללא cache. אחת הבעיות היא שזמן הביצוע של התוכנית יכול להפוך ללא דטרמיניסטי.

המשמעות היא שזמן הביצוע של קטע קוד מסוים עשוי להשתנות משמעותית, דבר שעלול להוות בעיה במערכות hard real-time שבהן נדרשת התנהגות דטרמיניסטית. כתוצאה מכך, ייתכן שתזדקק לדרך לשלוט בגישה לחלקים שונים של הזיכרון באמצעות ה-cache וה-store buffer.

ליבות מעבד השתמשו במשך זמן רב ב-store buffers כדי להחזיק stores מחויבים (committed) עד ששאר מערכת הזיכרון יכולה לעבד את ה-stores. ה-store נכנס ל-store buffer כשהוא מתחייב, ויוצא מה-buffer כאשר הבלוק שייכתב נמצא ב-cache במצב קוהרנטיות קריאה-כתיבה. store יכולה להיכנס ל-store buffer לפני שה-cache השיג הרשאות קוהרנטיות קריאה-כתיבה עבור הבלוק שייכתב; ה-store buffer מסתיר את ההשהיה של שירות store miss . מכיוון ש-stores הן תדירות, היכולת להימנע מעיכובים ברוב המקרים היא יתרון חשוב. כמו כן, אין סיבה לעכב את הליבה מכיוון שהליבה אינה תלויה בכלום; ה-store מבקשת לעדכן את הזיכרון אך לא את מצב הליבה.

כתיבה לזיכרון (זיכרון ראשי ו-cache-ים) ניתנת לאיחסון פנימי על ידי המעבד ב-store buffer לפני כתיבת הנתונים בפועל למיקום זיכרון. ניתן לשפר את ביצועי המערכת על ידי buffering ל-stores, כפי שמוצג במקרים הבאים:

- כשטרנזקציות זיכרון בעדיפות גבוהה יותר, כמו קריאה, מתחרות על גישה לזיכרון עם כתיבה, כתיבה יכולה להתעכב לטובת קריאה, מה שממזער או מבטל עיכוב ביצוע הוראות עקב קריאה של אופרנד זיכרון.

- כשהזיכרון תפוס, buffering ל-stores, בזמן שהזיכרון תפוס מסיר את הכתיבה מ-pipeline ביצוע הפקודות, מה שמשחרר משאבי ביצוע פקודות.

המעבד מנהל את ה-store buffer כך שיהיה שקוף לתוכנה. גישה לזיכרון בודקת את ה-store buffer, והמעבד משלים את הכתיבה לזיכרון מה-buffer לפי סדר התוכנית.
בארכיטקטורת x86 המעבד מרוקן את ה-store buffer על ידי כתיבת התוכן לזיכרון כתוצאה מביצוע כל אחת מהפעולות הבאות: פעולות: io, Serializing, fence, Locked, Interrupts ו-Exceptions.


## store buffer & combining


חלק מה-store buffers תומכים במיזוג כתיבה, שנקרא גם שילוב כתיבה. הם יכולים למזג מספר פעולות כתיבה, למשל, זרם של כתיבות לבייטים סמוכים, לאחת, ובכך להפחית את תעבורת הכתיבה לזיכרון החיצוני ולהגביר את הביצועים.

ה-store buffer לא מטפל בהכרח ב-cache lines מלאות. הסיבה לכך היא שהנתון שנשמר ב-store buffer מכיל רק את הערך שצריך לאחסן, ולא את שאר הנתונים שמצויים בשורת ה-cache המתאימה. זהו יתרון משמעותי, כי למעבד שמבצע את פעולת ה-store אין גישה למידע על הנתונים האחרים שנמצאים ב-cache line. עם זאת, כש-cache line המתאימה מגיעה ליעדה, ניתן למזג לתוכה את כל הערכים שמאוחסנים ב-store buffer ומתאימים ל-cache line הזו. לאחר המיזוג, ניתן להסיר את הערכים המתאימים מ-store buffer, בעוד ששאר המידע ב-cache line נותר ללא שינוי.

ה-store buffers יכולים להתנהג באופן דומה ל-store-combining buffers מכיוון שמספר כתיבות עשוי להיאסף באופן פנימי לפני העברת הנתונים ל-cache-ים או לזיכרון הראשי.

בכמה ארכיטקטורות , במיוחד באלה עם סידור חלש, מבוצע מיזוג של ערכי store buffer כדי ליצור התחייבות אחת ל-L1d. לדוגמה, ניתן למזג זוג של stores בגודל 32 ביטים לכל אחד, ולהפוך אותם לכתיבה אחת בגודל 8 בתים ל-cache L1d.

בביצוע של הוראות שמשנות זיכרון לרוב צריך לבצע קריאה של הזיכרון לפני הכתיבה עצמה בגלל שהתוכן ב-cache נשמר כ-cache line שלמות (לרוב  cache line צריכות להיות שלמות אבל יש מימושים שתומכים גם ב-cache line עם תוכן חלקי למשל רכיבים שמשתמשים ב-AMBA CHI) לכן יש לטעון את התוכן של ה-cache line לפני פעולת הכתיבה עצמה.

על מנת להשיג את ה-cache line עם הרשאות מתאימות המעבד עצמו צריך לשלוח הודעות מתאימות בפרוטוקול הקוהרנטיות, למשל במקרה של כתיבה שהתוכן של הזיכרון לא קיים ב-cache אז צריך לשלוח בקשה מתאימה (ב-MESI בקשת read-invalidate וב-AMBA CHI בקשת ReadUnique לדוגמה).
במימושים שונים האחריות הזאת נמצאת ברכיבים שונים למשל ב-x86 של intel קיים ה-line fill buffer ויש מימושים שמעברים את האחריות ל-store buffer עצמה (או לפחות רכיב שקוף לאחר ה-store buffer).


## store buffer & forward

תוצאה ישירה של השימוש ב-store buffer היא שהכתיבה שביצע המעבד לא נכתבת מיד ל-cache. כתוצאה מכך, בכל פעם שה-CPU מבצע קריאה לשורת cache, הוא בודק קודם כל את ה-store buffer שלו כדי לראות אם השורה המבוקשת כבר נמצאת שם. ייתכן שכתיבה לשורה זו כבר התבצעה על ידי ה-CPU, אך השורה עדיין לא נכתבה ל-cache כי הכתיבה ממתינה ב-store buffer. חשוב לציין שמעבד יכול לקרוא את הכתיבה הקודמת שלו מה-store buffer שלו, אך מעבדים אחרים לא יכולים לראות את הכתיבות הללו עד שהן נשטפות ל-cache. כלומר, מעבד לא יכול לסרוק את ה-store buffer של מעבדים אחרים.

התנהגות הזאת נקראת store forwarding (ידוע גם כ-bypassing) והיא מתייחסת למצב שבו הליבה יכולה לקרוא ערכים מתוך ה-store buffer שלה גם אם המידע עדיין לא נכתב לזיכרון הראשי.

ה-store forwarding מאפשר לרצף פעולות כתיבה לקריאה עם store buffer עשוי להיות נמוך יותר מהסכום של זמני הביצוע עבור פעולות load ו-store בנפרד בגלל שה-store forwarding מאפשר ל-load לקבל את הנתונים ישירות מה-store buffer, במקום לעבור דרך ה-cache.

## store buffer & ordering

באופן כללי, מעבדים מודרניים אינם משתמשים במודל זיכרון עם עקביות רציפה (Sequential Consistency), מה שמאפשר סידור מחדש של פעולות store-load. תכונה זו נכונה גם עבור ארכיטקטורות כמו x86 ו-SPARC-TSO.

שני stores יכולים להיות מסודרים מחדש אם לליבה יש store buffer שאינו פועל לפי סדר FIFO, כלומר הוא מאפשר ל-stores לצאת בסדר שונה מהסדר שבו הם נכנסו. מצב כזה יכול להתרחש כשה-store הראשון מקבל cache miss בזמן שהשני מקבל hit, או כאשר ה-store השני יכול להתמזג עם store מוקדם יותר. יש לשים לב שהסידורים מחדש הללו אפשריים גם אם הליבה מבצעת את ההוראות לפי סדר התוכנית שלה. סידור מחדש של stores לכתובות זיכרון שונות אינו משפיע על ביצוע thread יחיד. אבל, בליבה מרובת thread-ים, סידור מחדש כזה מאפשר לליבות שונות לראות ערכי זיכרון ישנים לפני שהן רואות את הכתיבה המעודכנת (כלומר, את הערך החדש). חשוב לציין שבעיה זו אינה נפתרת גם אם ה-store buffer מתנקז להיררכיית זיכרון קוהרנטית לחלוטין. קוהרנטיות עשויה להפוך את ה-cache-ים לבלתי נראים, אבל ה-stores כבר מסודרות מחדש.

ליבה בודדת של מעבד עושה שימוש ב-store buffer כדי להסתיר את זמן ההשהיה של store misses. כאשר store פורש מה-pipeline של המעבד, הוא נכנס ל-store buffer ומשם מתנקז למערכת ה-cache או הזיכרון. זה בטוח עבור ליבה בודדת כל עוד loads בודקים את ה-store buffer עבור stores בביצוע (outstanding) עם אותה כתובת. עם זאת, במערכות עם מספר ליבות, כללי הסדר של מודל עקביות רציפה (SC) מונעים שימוש ישיר ב-store buffer. ליבות המתוזמנות באופן דינמי יכולות להסתיר חלק מהשהייה של ה-store, אך לא את כולה. לשם כך הוצעו פתרונות אגרסיביים, כגון ספקולציות מעבר לחלון ההוראות, אשר כוללים פרישה ספקולטיבית של loads ו-stores אשר עברו misses, תוך שמירה על מצב ההוראות שנעשה בו שימוש ספקולטיבית בנפרד.

בעיות היישום של הוראות RMW אטומיות במודל TSO (Total Store Order) דומות לאלו של הוראות אטומיות במודל SC. ההבדל העיקרי הוא ש-TSO מאפשר ל-loads לעבור, כלומר להופיע לפני, stores קודמות שנכתבו ל-store buffer.
### store buffer & RMW

הוראות אטומיות מיוחדות במידה מסוימת מכיוון שהן עוקפות את ה-store buffer (או לפחות מתנהגות כאילו הן עוקפות אותו).

בביצוע הוראות RMW ה"כתיבה" (כלומר, ה-store) עשויה להיכתב ל-store buffer. כדי להבין את היישום של RMW אטומיים ב-TSO, הוראת RMW נחשבת כהוראת load שאחריה מיד באה הוראת store. חלק ה-load של ה-RMW לא יכול לעבור loads מוקדמים יותר עקב כללי הסידור של TSO. ייתכן שבתחילה נראה שחלק ה-load של ה-RMW יכול לעבור stores מוקדמות יותר ב-store buffer, אבל זה לא חוקי. אם חלק ה-load של ה-RMW עובר store מוקדמת יותר, אז חלק ה-store של ה-RMW יצטרך לעבור גם את ה-store המוקדמת יותר, שכן ה-RMW הוא זוג אטומי. אבל מכיוון של-stores אסור לעבור זו בזו ב-TSO, חלק ה-load של ה-RMW לא יכול לעבור גם store מוקדמת יותר.

אילוצי הסדר האלה על RMW משפיעים על היישום. מכיוון שלא ניתן לבצע את חלק ה-load של ה-RMW עד שסודרו stores מוקדמים יותר (כלומר, יצאו מ-store buffer), ה-RMW האטומי מנקז ביעילות את ה-store buffer לפני שהוא יכול לבצע את חלק ה-load של ה-RMW. יתר על כן, כדי להבטיח שניתן לסדר את חלק ה-store מיד לאחר חלק ה-load, חלק ה-load דורש הרשאות קוהרנטיות של קריאה-כתיבה, ולא רק הרשאות קריאה מספיקות ל-loads רגילים. לבסוף, כדי להבטיח אטומיות ל-RMW, ייתכן שבקר ה-cache לא יוותר על הרשאת קוהרנטיות לבלוק בין ה-load ל-store. יישום אופטימלי יותר של RMW אפשרי. לדוגמה, אין צורך לנקז את store buffer כל עוד:
1. לכל ערך שכבר נמצא ב-store buffer יש הרשאת קריאה-כתיבה ב-cache ושומר על הרשאת הקריאה-כתיבה ב-cache עד שה-RMW מתחייב. 
2. הליבה מבצעת בדיקה של ספקולציות load. באופן לוגי, כל ה-stores וה-loads הקודמים יתחייבו כיחידה (לפעמים נקראת "chunk") מיד לפני ה-RMW.

לפני ביצוע הוראה אטומית, הליבה מנקזת את ה-store buffer, משיגה את הבלוק עם הרשאות קוהרנטיות קריאה-כתיבה, ולאחר מכן מבצעת את חלק ה-load ואת חלק ה-store. מכיוון שהבלוק נמצא במצב קריאה-כתיבה, חלק ה-store מבוצע ישירות ל-cache, עוקף את ה-store buffer. בין ביצוע חלק ה-load לחלק ה-store, אם קיים חלון כזה, אסור לבקר ה-cache לפנות את הבלוק; אם תגיע בקשת קוהרנטיות נכנסת, יש לדחות אותה עד לביצוע חלק ה-store של ה-RMW. השיטה של TSO להטמעת RMW פשוטה, אך היא שמרנית מדי ומקריבה ביצועים מסוימים. יש לציין, ניקוז ה-store buffer אינו נדרש מכיוון שמודל relaxed מאפשר גם לחלק ה-load וגם לחלק ה-store של ה-RMW לעבור stores מוקדמות יותר. לפיכך, ניתן להשיג הרשאות קוהרנטיות של קריאה-כתיבה לבלוק ולאחר מכן לבצע את חלק ה-load וחלק ה-store מבלי לוותר על הבלוק בין שתי הפעולות הללו. ישנם יישומים נוספים של RMW אטומיים, אך הם אינם נידונים כאן.



---








---



