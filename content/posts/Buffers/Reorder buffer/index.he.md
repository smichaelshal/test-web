+++
Sources = [
"https://en.wikipedia.org/wiki/Out-of-order_execution",
"https://uops.info/background.html",
"https://arxiv.org/pdf/1810.04610",
"https://arxiv.org/pdf/2310.13212",
"https://stackoverflow.com/questions/64141366/can-a-speculatively-executed-cpu-branch-contain-opcodes-that-access-ram/64148401#64148401",
"https://en.wikipedia.org/wiki/Re-order_buffer",
"https://stackoverflow.com/questions/37725497/how-does-memory-reordering-help-processors-and-compilers",
"https://en.wikipedia.org/wiki/Register_renaming",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-11"
categories = [

]
series = [

]
title = "Reorder buffer"
+++

## מבוא

ה-reorder buffer הוא יחידת חומרה המשמשת באופן נרחב יחד עם אלגוריתם Tomasulo לתמיכה בביצוע פקודות לא מסודרות וספקולטיביות. הוא מבטיח שההוראות יתבצעו בסדר המתואם.

ה-buffer מיושם כמערך מעגלי, המיועד לספק תור לסדר הוראות שנמצאות בעיבוד לפי FIFO. הוא מאפשר רישום של תוצאות מול ההוראות כאשר הן מסתיימות, גם אם הן בוצעו מחוץ לסדר.

מעבדי x86 מודרניים מבצעים loads ספקולטיביות מוקדמות לפני טעינות אחרות, ולעיתים עלולים "להשמיד" ספקולציה שגויה של סדר הזיכרון אם הם מזהים שהעותק שלהם של שורת ה-cache לא נשאר תקף מאז שה-load התבצעה בפועל, בהתאם להתרות הארכיטקטוניות. במקרה כזה, הם משליכים את תוכן ה-reorder buffer כדי לחזור למצב עקבי ולהתחיל מחדש את הביצוע. זה קורה בדרך כלל כאשר ליבה אחרת משנה את שורת ה-cache, אך עשוי להתרחש גם אם load חזה בטעות שלא תדרוש טעינה מחדש של store. (כמובן, מעבדי x86 אמיתיים יכולים לסדר מחדש בחופשיות טעינות לפני stores.)

התחייבות ל-cache L1d מתרחשת לאחר שההוראת store פורשת מה-reorder buffer, כלומר כאשר ידוע שההוראה store אינה ספקולטיבית, וה-store buffer המתאים לה הושלם והפך לנתון תקף להתחייב ל-cache ולגלות אותו בצורה גלובלית. ה-store buffer מנתק את הביצוע מהראות של ליבות אחרות ומבודד את הליבה הנוכחית מה-store-miss, כך שזהו רכיב חשוב גם במעבדים הנעשים לפי סדר.

לפני ש-entry ב-store buffer "מסתיימת", ניתן פשוט למחוק אותה יחד עם ערך ה-reorder buffer המצביע עליה, במקרה של חזרה על ספקולציות שגויות.


בנוגע לשילוב כתיבה, אם יש מיקום זמני בכניסות ROB (כלומר, אם הוראות קרובות זו לזו נכתבות קרוב זה לזה בזמן), ניתן לשלב כתיבה על ערכי ROB, מה שעשוי להפחית את הצורך בפורטים נפרדים ל-ROB ול-physical register file. עם זאת, השפעה זו לא תמיד ברורה, במיוחד כאשר יש בנקי physical register file.

הרגיסטר הפיזי הקודם שהוקצה לאותו רגיסטר ארכיטקטוני נשמר יחד עם ההוראה ב-reorder buffer, שהוא FIFO שמחזיק את ההוראות בסדר תוכנית בין שלבי הפענוח והסיום.

תוצאות הביצוע נכתבות ל-reorder buffer, ל-reservation station.

## במעבדי intel

מעבדי אינטל מוקדמים שתומכים בביצוע מחוץ לסדר השתמשו בתור תוצאות שנקרא reorder buffer, בעוד שמעבדים מחוץ לסדר מאוחרים יותר עושים שימוש ב-register maps.

באופן ספציפי, מיקרו-מעבדים ממשפחת אינטל P6 כוללים גם reorder buffer (ROB) וגם register alias table (RAT). ה-ROB משמש בעיקר להתאוששות מטעויות בניבוי branch-ים.

כדי לאפשר לרכיבים שונים לפעול במקביל, ממוקמים ביניהם buffers. לדוגמה, המפענח פיענח את הוראות הקלט ומאחסן את ה-µops המתקבלים בתור פענוח הוראות (instruction decode queue - IDQ). ה-renamer שואב µops מה-IDQ, מבצע את המשימות שלו ומאחסן את ה-µops ב-reorder buffer, תוך שהוא גם מעביר אותם ל-scheduler. כל רכיב pipeline יכול לעבד מספר הוראות או µops בכל מחזור, בהתאם לרוחב העיבוד המקביל שלו. מספר ה-µops המדויק שמעובד על ידי רכיב במחזור מסוים תלוי במאפייני רכיב ה-pipeline וגם במאפיינים של ה-µops המעובדים באותו מחזור.

ה-reorder buffer מאחסן את ה-μops בסדרם המקורי עד לסיום ביצועם. הוא גם אחראי על הקצאת רגיסטרים, כלומר, מיפוי רגיסטרים ארכיטקטוניים לרגיסטרים פיזיים, ומבצע את תהליך ה-register renaming כדי למנוע תלות כוזבת בין μops.

במיקרו-ארכיטקטורות מסוימות, ה-reorder buffer יכול גם לבצע ישירות µops מיוחדים, כולל NOPs, אפס ניבים (כגון XOR של רגיסטר עם עצמו), ומהלכי רגיסטר לרגיסטר כמו move elimination.

לאחר מכן, ה-µops שנותרו מועברים ל-scheduler (המוכר גם כ-reservation station), שממיין את ה-µops בתור עד שכל אופרנד המקור שלהם יהיה מוכן.

ה-renamer שואב µops מה-IDQ ומאחסן את כולם ב-reorder buffer, ממנו הוא גם מנפיק את ה-µops ל-scheduler . מספר ה-µops המרבי שה-renamer יכול לעבד בכל מחזור נקרא issue width.

ה-µops נשארים ב-reorder buffer עד שהם מוכנים לפרוש. µop נחשב מוכן לפרוש כאשר הוא סיים את הביצוע וכל ה-µops הקודמים בסדר התוכנית מוכנים גם הם לפרוש.

ה-renamer יכול לבצע ישירות מחלקות מסוימות של µops, כמו register moves, NOPs, או ניבי אפס; µops כאלה נשלחים ל-reorder buffer אך לא ל-scheduler. ניבי אפס הם הוראות שמגדירות תמיד את רגיסטר היעד ל-0, ללא תלות בערכים ברגיסטרי המקור. דוגמה לכך היא XOR של רגיסטר עם עצמו.


דוגמה להתנהגות של ה-reorder buffer ניתן למצוא בשימוש בהוראת `MOV` או `MOVZX` במקרים מסוימים הן עשויות להיות הוראות אפס השהייה בכמה מיקרו-ארכיטקטורות, דבר שניתן לביצוע על ידי ה-reorder buffer (ביצוע move elimination). עם זאת, ביטול move אינו תמיד מצליח; 

אם לפחות אחד משני האופרנדים של הרגיסטר אינו אופרנד מרומז, ניתן להשתמש באותו אופרנד עבור שני האופרנדים. אולם, אם אחד האופרנדים נקרא וגם נכתב, לא ניתן להוסיף הוראה לשבירת תלות עבור תלות מרומזת זו. במקרה זה, לא ניתן לנתח את השהיה של שני האופרנדים בנפרד. יתרה מכך, ישנן הוראות שמתנהגות בצורה שונה אם אותו רגיסטר משמש למספר אופרנדים. לדוגמה, הוראות כמו XOR ו-SUB עם שני אופרנדים של רגיסטר, שהן ניבי אפס (zero idioms) (כגון XOR עם עצמו), תמיד יגדירו את הרגיסטר לאפס ללא תלות בתוכן הרגיסטר בפועל אם אותו רגיסטר משמש לשני האופרנדים. במיקרו-ארכיטקטורות האחרונות, הוראות אלו שוברות את התלות ברגיסטר שבו נעשה שימוש; בחלק מהמיקרו-ארכיטקטורות, הן עשויות להיות מופעלות על ידי ה-reorder buffer מבלי להשתמש בפורטי הביצוע. ישנן גם הוראות אחרות שמתנהגות אחרת בכמה מיקרו-ארכיטקטורות כאשר נעשה שימוש באותו רגיסטר, כמו הוראת SHLD.

