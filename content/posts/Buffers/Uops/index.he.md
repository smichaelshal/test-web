+++
Sources = [
"https://en.wikipedia.org/wiki/Micro-operation",
"https://en.wikichip.org/wiki/macro-operation_fusion",
"https://dl.acm.org/doi/pdf/10.1145/3524059.3532396",
"https://arxiv.org/pdf/2310.13212",
"https://en.wikipedia.org/wiki/CPU_cache",
"https://en.wikipedia.org/wiki/Microcode",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-11"
categories = [

]
series = [

]
title = "Uops"
+++




## מבוא

במעבדים, micro-operations (המכונות גם micro-ops או μops, ובאופן היסטורי micro-actions) הן הוראות ברמה נמוכה המשמשות ליישום הוראות מכונה מורכבות בעיצובים מסוימים (לעיתים מכונות פקודות מאקרו בהקשר זה).

בדרך כלל, micro-operations מבצעות פעולות בסיסיות על נתונים המאוחסנים ברגיסטר אחד או יותר, כמו העברת נתונים בין רגיסטרים או בין רגיסטרים לבין bus-ים חיצוניים של המעבד (CPU), וכן ביצוע פעולות אריתמטיות או לוגיות על הנתונים ברגיסטרים. במחזור fetch -> decode -> execute טיפוסי, כל שלב בהוראת מאקרו מתפרק במהלך הביצוע, כך שהמעבד קובע ומבצע סדרה של micro-operations. הביצוע של micro-operations מתבצע תחת שליטת יחידת הבקרה של המעבד, אשר מבצעת אופטימיזציות שונות כמו סידור מחדש, היתוך ואחסון ב-cache.

### אופטימיזציות

צורות שונות של μops היו הבסיס ל-routine מיקרוקוד מסורתיות, שנועדו לפשט את יישום עיצובי המעבד או את הרצף של פעולות מרובות שלבים או מצבי כתובת מסוימים. במעבדים יותר מודרנים ה-μops שימשו בצורה שונה כדי לאפשר למעבדי CISC מודרניים להתמודד טוב יותר עם ביצוע מקבילי וספקולטיבי אסינכרוני. בדומה למיקרוקוד המסורתי, מבוצע חיפוש בטבלה (או פעולה דומה) כדי לאתר את רצף ה-μop המתאים על סמך הקידוד והסמנטיקה של הוראת המכונה במהלך הפענוח או התרגום. אולם, במקום שרצפי ה-μop ישלטו במעבד ישירות מ-microcode-ROM, הם מאוחסנים באופן דינמי לצורך תזמון מחדש לפני הביצוע.

ה-buffering הזה מאפשר לנתק את שלבי האחזור והפענוח מיחידות הביצוע יותר מאשר בעיצוב מקודד מסורתי (או hard-wired). זה מעניק חופש מסוים בבחירת סדר הביצוע של ההוראות, מה שמאפשר להוציא מקביליות ברמת ההוראה מתוכנית רגילה עם thread יחיד (בתנאי שמוודאים שאין תלות בין ההוראות). כך מתאפשר לנתח ולסדר מחדש את רצפי הקוד בצורה שתייעל את המיפוי והתזמון של ה-μops על משאבי המעבד (כגון ALUs, יחידות load/store וכו'). ברמת ה-μop, ייתכן שתתי-פעולות של הוראות מכונה שונות יתמזגו ברצף מסוים, וכתוצאה מכך הוראות מכונה מסודרות חלקית ישירות מתוך שליחת פקודות מיקרו מכמה הוראות מאקרו.

חשוב לציין שהיתוך (fusion) של micro-op הוא תהליך שבו micro-operation מורכבת אחת מחליפה מספר micro-ops פשוטות יותר במקרים מסוימים. תהליך זה נועד למזער שינויים במצב, לשפר את השימוש ב-reorder buffer ולהפחית את צריכת החשמל. תהליך זה מיושם בחלק מתכנוני המעבד המודרניים.

מעבדים גם מבצעים את ההפך כאשר הדבר מתאים: הם משלבים רצפי הוראות מכונה מסוימים (כגון השוואה ואחריה קפיצה מותנית) ל-μop מורכב יותר המתאים יותר לביצוע, מה שמאפשר ביצוע מהיר יותר או עם פחות משאבים מעורבים. תהליך זה מכונה גם macro-op fusion.

דרך נוספת לשפר את הביצועים היא לאחסן את המיקרו-פעולות המפוענחות ב-cache מיקרו-פענוח, כך שבפעם הבאה שהוראת המאקרו מבוצעת, המעבד יכול לגשת ישירות למיקרו-פעולות המפוענחות מה-cache, במקום לפענח אותן מחדש. דוגמה ידועה לכך היא cache מעקב הביצוע במיקרו-ארכיטקטורת Intel NetBurst (Pentium 4). ניתן להגדיר את גודל ה-cache במונחים של כמה אלפי מיקרו-פעולות (או כפול של 1024) שהוא יכול לאחסן: Kμops.


### Macro-Operation Fusion (MOP Fusion)

ה-Macro-Operation Fusion (המכונה גם Macro-Op Fusion, MOP Fusion או Macrofusion) היא טכניקת אופטימיזציה בחומרה הנמצאת במיקרו-ארכיטקטורות מודרניות רבות. בטכניקה זו, סדרת פעולות מאקרו סמוכות מתמזגות לפעולת מאקרו אחת לפני או במהלך תהליך הפענוח. הוראות אלו מפוענחות לאחר מכן ל-fused-µOPs.

הטכניקה מאפשרת לצמצם את מספר ההוראות שצריך לבצע, מה שמאפשר לבצע יותר עבודה עם פחות משאבים. הרעיון מאחורי היתוך פעולות מאקרו הוא לשלב מספר הוראות סמוכות להוראה אחת, אשר נשארת ממוזגת לאורך כל שלבי העיבוד שלה. כך, הוראות ממוזגות יכולות לייצג יותר עבודה תוך שימוש בפחות ביטים, לפנות יחידות ביצוע, לעקוב אחר מידע בצורה יעילה יותר (כמו ביחידת ה-renaming), לחסוך ברוחב הפס של ה-pipeline בכל שלביו מפענוח ועד פרישה, ובכך להפחית את צריכת החשמל.

היבט ייחודי בטכניקה זו הוא שהיא גם משפרת ביצועים בעומסי עבודה פשוטים, כמו במקרים של שפות תכנות מפורשות רבות.

### Arm

ארכיטקטורת Arm תומכת בכמה פעולות של היתוך מאקרו-אופ במיקרו-ארכיטקטורות המתקדמות שלה:

- `movw` + `movt`
- `aese` + `aesmc`
- `aesd` + `aesimc`

ביצוע רצף של `movw` ואחריו `movt` הוא שיטה נפוצה לטעינת ערך של 32 סיביות לתוך רגיסטר.

### x86



אינטל משתמשת ב-macro-op fusion בכל המיקרו-ארכיטקטורות המודרניות שלה מאז משפחת Core.

לאחר שזוהו והוגדרו גבולות ה-macro-ops, הם מועברים לתור ההוראות לפני שהם מגיעים למפענחים. בשלב זה של ה-pipeline, מתבצע היתוך macro-op, מה שחוסך ברוחב הפס של הפענוח כבר בשלב מוקדם זה.

הוראות branching מותנות הן פעולות נפוצות מאוד ברוב עומסי העבודה. בתהליך היתוך, משווים זוג של שתי הוראות תלויות מול קבוצת קריטריונים, כגון שאופרנד המקור או היעד הראשון חייב להיות אופרנד, והאופרנד השני (אם קיים) חייב להיות ערך מיידי או כתובת זיכרון שאינה יחסית ל-RIP. ההיתוך מחליף את שתי ההוראות בהוראה אחת המייצגת את שתי הפעולות.

ההיתוך מתבצע כאשר הוראת שינוי דגל (למשל CMP או ADD) מופיעה מיד לפני הוראת קפיצה מותנית. הפלט המתקבל הוא הוראת הפעלה ו-branch אחד, שנשארת מאוחדת לאורך כל שלבי ה-pipeline עד יחידות הביצוע, שם היא עשויה להתבצע בפורט בודד או בהנפקה כפולה בשתי יציאות מתאימות.

- שתי ההוראות חייבות להופיע ברצף, ללא הוראות אחרות ביניהן.
- ההוראה הראשונה חייבת להיות אחת מהבאות: CMP, TEST, ADD, SUB, INC, DEC או AND.
- ההוראה השנייה חייבת להיות קפיצה מותנית (למשל, JA, JAE, JE, JNE).
- היתוך לא יתבצע אם ההוראה הראשונה מסתיימת בבייט 63 של שורת cache, וההוראה השנייה מתחילה בבייט 0 של השורה הבאה.

בנוסף, ניתן לבצע רק macrofusion אחד בכל מחזור. אם קיימת אפשרות לבצע שני היתוכים, רק הזוג הראשון יתמזג, והזוג השני ימשיך ללא התמזגות.


ה-Micro fusion הוא טכניקת אופטימיזציה שבה שני µops מאותה הוראה מתמזגים ומטופלים כ-µop אחד בשלבים המוקדמים של ה-pipeline. הם נפרדים לשתי µops נפרדות לפני שלב הביצוע ב-back end. כל סוגי המפענחים, כולל המפענחים הפשוטים, יכולים לפלט micro-fused µops. יש לציין שניתן למזג רק סוגים מסוימים של µops, כאשר לפחות אחד מהם חייב להיות µop של load או store.

ה-Micro-fused µops שנחלקים על ידי ה-renamer נקראים unlaminated µops לאחר הפיצול. הם מנותבים ל-scheduler בצורה של שתי µops.


חומרת ה-fetching וה-decoding של ה-Pentium Pro שולפת הוראות ומפענחת אותן לסדרות של micro-ops המועברות ליחידת הביצוע, שמתזמנת ומוציאה לפועל את ה-micro-ops, אולי עושה זאת מחוץ לסדר. הוראות מורכבות מיושמות על ידי microcode המורכב מרצפים מוגדרים מראש של micro-ops.


