+++
Sources = [
"https://docs.kernel.org/arch/x86/buslock.html",
"https://lwn.net/Articles/806466/",
"https://lwn.net/Articles/911219/",
"https://docs.kernel.org/arch/x86/buslock.html",
"https://pve.proxmox.com/wiki/Split_lock_detection",
"https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html#split-lock-mitigate-x86-only",
"https://x86.lol/generic/2023/11/07/split-lock.html",
"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-kememorybarrier",
"https://preshing.com/20120515/memory-reordering-caught-in-the-act/",
"https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf",
"https://c9x.me/x86/html/file_module_x86_id_159.html",
"https://cdrdv2-public.intel.com/825743/325462-sdm-vol-1-2abcd-3abcd-4.pdf",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-11"
categories = [

]
series = [

]
title = "x86 Lock"
+++



## lock prefix

ה-lock prefix הוא קידומת של של ה-opcode (הקידומת היא `0xF0`) והוא מאפשר לבצע פעולות אטומיות.

ה-lock prefix גורמת לאות `LOCK#` של המעבד להישאר פעיל במהלך ביצוע ההוראה המצורפת אליה, מה שהופך את ההוראה לאטומית. בסביבה עם ריבוי מעבדים, האות `LOCK#` מבטיח שהמעבד המחזיק באות יש שימוש בלעדי בכל זיכרון משותף בזמן שהאות פעיל.

ניתן להוסיף את קידומת `LOCK` רק לקבוצה מסוימת של הוראות, ורק במקרים שבהם אופרנד היעד של ההוראה הוא אופרנד זיכרון. הוראות מסוימות שניתן להוסיף להן את קידומת `LOCK` כוללות:

- `ADD`
- `AND`
- `BTS`
- `CMPXCHG`
- `DEC`
- `INC`
- `SUB`
- `XOR`
- `XADD`
- `XCHG`

שימוש בקידומת `LOCK` עם אחת מההוראות הללו כאשר אופרנד המקור הוא בזיכרון עלול לגרום ל-exception קוד לא מוגדר (`#UD`). כמו כן, exception כזה יתרחש אם קידומת `LOCK` תתווסף להוראה שאינה כלולה ברשימה זו. עם זאת, יש לציין שהוראת `XCHG` תמיד מגדירה את האות `LOCK#`, בין אם קידומת `LOCK` קיימת או לא.


## cache lock & bus lock

המעבד מבטיח אטומיות לפעולות RMW על ידי נעילה של רכיבים ומתן גישה בלעדית למעבד המבצע. המעבד תומך בנעילת bus לצורך ביצוע פעולות זיכרון נבחרות, כמו פעולות RMW באזורי זיכרון משותפים, אשר חייבות להתבצע בצורה אטומית.

במעבדי ישנים יחסית, אות `LOCK#` תמיד מופעל על ה-bus במהלך פעולת lock, גם כאשר אזור הזיכרון הננעל נשמר ב-cache הפנימי של המעבד.

במעבדי יותר חדשים (כמו במשפחות המעבדים P6 והמעבדים החדשים יותר של intel), אם אזור הזיכרון הננעל במהלך פעולת lock מאוחסן ב-cahce L1 או L2 של המעבד כזיכרון write-back וכלול כולו ב-cache line אחת, ייתכן שהמעבד לא יפעיל את אות `LOCK#` על ה-bus. במקרה זה, המעבד יטפל בנעילה באופן פנימי על ידי שינוי מיקום הזיכרון ב-cache עצמו, תוך שימוש במנגנון קוהרנטיות ה-cache שלו כדי להבטיח שהפעולה מתבצעת בצורה אטומית (ב-amd למשל משתמשים בפרוטוקול MOESDIF). תהליך זה נקרא cache locking או cacheable lock. מנגנון קוהרנטיות ה-cache מונע אוטומטית ממספר מעבדים ששומרים את אותו אזור זיכרון ב-cache לשנות את הנתונים באותו אזור בו-זמנית.

בביצוע גישה לזיכרון מסוג cacheable מחולקת על פני cache lines וגבולות page-ים, חלק מהמעבדים אינם מבטיחים אטומיות גישה זו במצב רגיל. כדי להבטיח אטומיות במקרים כאלה, נדרשים אותות בקרת bus שמאפשרים לתת-מערכות זיכרון חיצוניות להבטיח שגישה מחולקת תהיה אטומית. עם זאת, גישות לא מיושרות לנתונים עלולות לפגוע בצורה משמעותית בביצועי המעבד ולכן יש להימנע מהן ככל האפשר.

האות `LOCK#` שמוגדר אוטומטית במהלך פעולות זיכרון קריטיות מסוימות, כדי לנעול את ה-bus של המערכת. כאשר אות זה מופעל, כל בקשה לשליטה ב-bus מצד מעבדים אחרים או סוכני bus נחסמת.

כדי להבטיח באופן מפורש את הסמנטיקה של lock, תוכנה יכולה להשתמש בקידומת `lock` יחד עם קבוצה מסוימת של הוראות, כאשר הוראות אלה משמשות לשינוי מיקום בזיכרון. אם קידומת `lock` משמשת בהוראה אחרת שאינה מורשת לקבל `lock` או כשלא מתבצעת כתיבה לזיכרון, יופק exception קוד לא חוקי (`#UD`).

חלק ממעבדי Intel ו-AMD מספקים אפשרות לדווח על נעילת bus לתוכנת המערכת באמצעות ה-exception `#DB`. מעבדים חדשים מאפשרים גם דיווח על גישה split lock שיכולה להוביל ל-exception `#AC`.

בנוסף אות `LOCK#` עלול גם לגרום ל-VM Exit בהתאם להגדרות מסוימות.


## split lock

במערכות x86, בניגוד לארכיטקטורות רבות אחרות, קיימת תמיכה בפעולות אטומיות שמשפיעות על יותר מ-cache line אחת. עם זאת, תמיכה זו גובה מחיר, הן בביצועי המערכת והן בהיבטי האבטחה.

האתגר בפעולות אטומיות שחוצות גבולות של שורות cache נובע מהצורך להבטיח ששני ה-cache lines יהיו מוגנים בו-זמנית מפני גישה מקבילה. כדי למנוע קונפליקטים כאלה, נדרשת נעילת ה-bus למשך כל זמן הפעולה, דבר שיכול לגרום לעיכוב של כל מעבד אחר במערכת.

נעילת bus המערכת מתרחשת כאשר מתבצעת פעולה אטומית שבה האופרנד חוצה שני cache lines. מכיוון שהאופרנד מתפרס על פני שני cache lines והפעולה חייבת להתבצע באטומיות, המערכת נאלצת לנעול את ה-bus על מנת לאפשר למעבד גישה מסונכרנת לשתי השורות הללו.

נעילת bus של המערכת יכולה להתרחש בעקבות split lock, כלומר גישת lock לזיכרון write-back שבו האופרנד מחולק בין שתי cache lines, או בעקבות כל גישת lock לזיכרון שאינו מסוג write-back. נעילה זו גורמת לעיכוב משמעותי, העשוי להתארך לאלפי מחזורים, בהשוואה לפעולה אטומית המתבצעת בתוך cache line אחת. מעבר לכך, היא משפיעה לרעה על הביצועים של ליבות אחרות במעבד ויכולה לגרום לירידה כללית בביצועי המערכת כולה.

בעצם, גישת split lock היא גישה בלתי תקינה לזיכרון, משהו שארכיטקטורת x86 הייתה סלחנית כלפיו באופן יחסי. אך כאן יש הבדל חשוב: בעוד שגישה לא מיושרת רגילה גורמת להאטה בביצוע הפעולה הספציפית בלבד, split locks גורמים להאטה בביצועים של המערכת כולה כולל רכיבים חיצוניים כמו רכיבי DMA. העיכוב של אלפי מחזורי שעון עלול להיות הרסני במיוחד במערכות זמן אמת. בנוסף, split locks יכולים לשמש ככלי למתקפת DoS יעילה הפוגעת בכל המערכת.

בתרחיש של התקפה זדונית, תוכנה הרצה בלולאה הדוקה ומשתמשת ב-split lock יכולה לפגוע קשות בביצועים של המערכת כולה, ולמעשה לשבש את פעולתה בצורה משמעותית.

### התמודדות עם הבעיה ב-linux

החל מגרסה 5.19 בקרנל של לינוקס ניתן להפעיל מנגנון לזיהוי נעילות bus או נעילות הנגרמות מגישה split lock באמצעות הגדרת הפרמטר `split_lock_detect` עם הערך המתאים.

כאשר זיהוי זה מופעל (ובמידה שקיימת תמיכה בחומרה), כל הוראה אטומית הניגשת לנתונים החוצים גבולות של שורות cache תגרום ליצירת exception של בדיקת יישור (alignment check exception) במקרה של זיהוי split lock, או ל-debug exception במקרה של זיהוי נעילת bus.

אם מנגנון הפחתת ה-split locks מושבת, יש סיכון ש-guests זדוניים במכונות וירטואליות יוכלו לבצע התקפות DoS נגד ה-host או נגד guests אחרים, דבר שעלול להשפיע לרעה על יציבות וביצועי המערכת.

לפרמטר `split_lock_detect` יש מספר ערכים שניתן לקבוע וכל אחד יגרום להתנהגות שונה:

- כברירת מחדל שמגיע במצב `warn`, תהליכים המבצעים split lock נענשים על ידי האטת ביצועיהם, אך אינם נהרגים. כאשר מתבצעת נעילה מפוצלת, הקרנל יוצר עיכוב של 10 אלפיות שנייה ומבצעת הסדרה (serialization) של התהליך באמצעות semaphore התהליכים האחרים שגם גורמים ל-split locks. במצב זה, אם תוכנה זדונית מנסה לנצל נעילות מפוצלות, היא תגרום להאטה בעצמה, אך השפעתה על שאר המערכת תהיה מינימלית.
  הקוד שמבצע את זה נמצא ב-`arch/x86/kernel/cpu/intel.c` בפונקציה `split_lock_warn` ([קישור לקוד](https://elixir.bootlin.com/linux/v6.10/source/arch/x86/kernel/cpu/intel.c#L1145)).

- ניתן להגדיר שתהליכי משתמש שמנסים לבצע פעולה של split lock יקבלו את אות ה-`SIGBUS`.

יש עוד ערכים שניתן להעביר לפרמטר ואפשר לקרוא עליהם [בתיעוד של הקרנל](https://docs.kernel.org/arch/x86/buslock.html).

כדי לבטל את ההאטה לא באופן קבוע אפשר לשנות את הערך של `/proc/sys/kernel/split_lock_mitigate`, ערך `0` רק מזהיר לגבי split lock וערך `1` מבצע את העונש ומאט את התהליכים הסוררים.


## ordering

כל הוראה עם lock prefix, כמו `xchg`, פועלת גם כמחסום זיכרון מלא. זאת בתנאי שלא נעשה שימוש בהוראות SSE או בזיכרון מסוג write-combined.

בביצוע פעולה עם lock רק לאחר שכל פעולות הזיכרון הקודמות הושלמו, המעבד יתחיל לבצע את פעולות הזיכרון הנדרשות על ידי ההוראות שעוקבות אחרי ההוראה עם ה-lock.

במילים אחרות, ה-lock prefix מבטיח שהמעבד ינהל את סדר הביצוע של פעולות הזיכרון הקשורות להוראה האטומית, בכך שהיא מוודאת שכל פעולות הזיכרון הקודמות הושלמו קודם להחלה של פעולות הזיכרון הבאות. אפשר לחשוב על זה בתור המתנה של המעבד שמחכה שה-store buffer יתרוקן (במציאות זה הרבה יותר מורכב כי יש עוד הרבה מאוד גורמים לביצוע out-of-order).

ההתנהגות הזאת יכולה להשתנות ולכן אם צריך סדר זיכרון צריך להשתמש במחסומים מתאימים כמו `mfence`.


