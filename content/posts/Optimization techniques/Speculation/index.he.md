+++
Sources = [
"https://en.wikipedia.org/wiki/Speculative_execution",
"http://infolab.stanford.edu/pub/cstr/reports/csl/tr/95/685/CSL-TR-95-685.pdf",
"https://github.com/paulmckrcu/oota",
"https://pages.cs.wisc.edu/~markhill/papers/primer2020_2nd_edition.pdf",
"https://lwn.net/Articles/255364/",
"https://en.wikipedia.org/wiki/Branch_predictor",
"https://developer.arm.com/documentation/den0024/a/Memory-Ordering",
"https://www.kernel.org/doc/Documentation/memory-barriers.txt",
"https://github.com/torvalds/linux/blob/master/tools/memory-model/Documentation/explanation.txt",
"https://github.com/ARM-software/speculation-barrier/",
"https://developer.arm.com/documentation/100076/0100/A32-T32-Instruction-Set-Reference/A32-and-T32-Instructions/CSDB",
"https://developer.arm.com/documentation/ddi0487/latest/",
"https://developer.arm.com/documentation/ddi0602/2023-06/Base-Instructions/SB--Speculation-Barrier-",
"https://developer.arm.com/documentation/102336/0100/Memory-barriers",
"https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/StrongModel.html",
"https://acg.cis.upenn.edu/papers/cav12_axiomatic_power.pdf",
"https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf",
"https://developer.arm.com/documentation/100941/0101/Memory-attributes",
"https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/memory-access-ordering-part-2---barriers-and-the-linux-kernel",
"https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/memory-access-ordering---an-introduction",
"https://blog.stuffedcow.net/2014/01/x86-memory-disambiguation/",
"https://stackoverflow.com/questions/37725497/how-does-memory-reordering-help-processors-and-compilers",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-11"
categories = [

]
series = [

]
title = "Speculation"
+++
# ספקולציות

## מבוא


ביצוע ספקולטיבי הוא שיטת אופטימיזציה במערכות מחשב, שבה מבוצעות משימות מראש, לפני שנודע בוודאות אם הן נדרשות. המטרה היא לחסוך זמן ולמנוע עיכובים בביצוע העבודה לאחר שמתברר שהיא נדרשת. אם בסופו של דבר מתברר שהמשימה לא הייתה הכרחית, המערכת מבטלת את רוב השינויים שבוצעו ומתעלמת מתוצאות הביצוע.

מטרת הביצוע הספקולטיבי היא להגדיל את ניצול המשאבים במערכת ולהפחית עיכובים. השיטה משמשת בתחומים רבים, כמו חיזוי נתיבי branch במעבדים עם pipeline, חיזוי ערכי נתונים לניצול מקומיות ערכית, ושליפת נתונים מראש מהזיכרון.

מעבדים מודרניים, בעלי pipeline-ים, משתמשים בביצוע ספקולטיבי כדי להפחית את העיכוב שנגרם מהוראות branch מותנות. הם עושים זאת באמצעות חיזוי נתיב ההוראות הנכון על בסיס ההיסטוריה של ביצועי branch קודמים. הוראות מתוזמנות מראש, לפני שמובהר אם הן נחוצות, כדי לשפר את הביצועים ולהשיג ניצול מרבי של המשאבים.

כאשר כתיבה (store) מחוייבת (committed) ל-cache, היא הופכת לגלויה ל-thread-ים הפועלים על ליבות אחרות, בהתאם לפרוטוקול הקוהרנטיות של ה-cache. בשלב זה, קשה או בלתי אפשרי להחזיר את הכתיבה לאחור, שכן ייתכן שליבה אחרת כבר קיבלה עותק מהערך שנכתב. לכן, כדי למנוע פגיעות ולוודא שה-store לא תגרום לבעיות, יש להמתין ולוודא שאין ספקולציות שגויות קודמות (כמו חיזוי branch שגוי) לפני שניתן לבצע את ההוראה של ה-store ל-cache L1d.

ללא סידור מחדש של store-load, כל load חייבת להמתין עד שכל ה-stores הקודמים לה יפרשו (הסתיימו) לחלוטין ויתקבלו על ה-cache לפני שהיא יכולה לקרוא ערך מה-cache לשימוש בהוראות מאוחרות יותר. רגע ההעתקה של ערך מה-cache לרגיסטר הוא הזמן הקריטי שבו הוא מתרחש עם סדר הקוהרנטיות של הקריאות והכתיבות למיקום זיכרון מסוים.

במעבדים מודרניים, ה-stores עוברות מה-store buffer ל-L1d לאחר שההוראת ה-store המתאימה פרשה מה-ROB. כמות מסוימת של stores בוגרות יכולה להיות מאוחסנת ב-store buffer, מה שמונע את הבזבוז בזמן כתוצאה מ-cache misses. ניתן גם לשים לב שההתחייבות ל-L1d יכולה להתרחש כחלק מהפרישה, אם כי זה עלול לוותר על שיפור הביצועים הקיים. ביצוע store יתבצע על ידי כתיבת הכתובת והנתונים לתוך ה-store buffer, מה שמאפשר ביצוע ספקולטיבי עד שהנתונים יהיו מוכנים, כאשר ה-store buffer שומר על הספקולציות פרטיות עד שיתחייבו.

### גרסאות של ביצוע ספקולטיבי

#### ביצוע להוט (Eager Execution)

ביצוע להוט הוא גרסה של ביצוע ספקולטיבי, שבה המעבד מבצע את כל נתיבי ה-branch המותנה. לאחר מכן, התוצאה הנכונה מחויבת (committed) רק אם ההחלטה הייתה נכונה. בתיאוריה, אם היו משאבים בלתי מוגבלים, ביצוע להוט היה מספק את אותם ביצועים כמו חיזוי branch מושלם. אך בפועל, מכיוון שהמשאבים מוגבלים, יש להפעיל ביצוע להוט בזהירות, שכן כל רמת branch נוספת מגדילה את צריכת המשאבים באופן אקספוננציאלי.

#### ביצוע חזוי (Predictive Execution)

ביצוע חזוי הוא סוג נוסף של ביצוע ספקולטיבי שבו המעבד צופה תוצאה מסוימת וממשיך לבצע את ההוראות בהתאם לנתיב החזוי, עד שהתוצאה הסופית מאומתת. אם התחזית הייתה נכונה, הביצוע ממשיך ומחויב; אם לא, יש לבטל את התוצאות ולהתחיל מחדש. טכניקות חיזוי נפוצות כוללות חיזוי branch-ים וחיזוי תלות בזיכרון, ובגרסה כללית יותר, חיזוי ערכים.

#### Runahead Execution

טכניקת ה-runahead מאפשרת למעבד לעבד מראש הוראות במהלך מחזורי זמן שבהם מתרחשות cache misses. באמצעות גישה זו, המעבד יוצר קריאות מקדימות של הוראות ונתונים על ידי ביצוע הוראות שעלולות להוביל להחמצות cache, לפני שהן מתרחשות בפועל. טכניקה זו מסתירה את זמני ההשהיה שנגרמים עקב החמצות בזיכרון. ב-runahead, המעבד משתמש במשאבים שאינם פעילים כדי לחשב כתובות ולבצע פעולות שאינן תלויות בהחמצות cache. לאחר שהמעבד פותר את ההחמצה הראשונית, הוא מוחק את כל התוצאות שהושגו במהלך ה-runahead וחוזר לביצוע רגיל. מקרה השימוש העיקרי לטכניקה זו הוא התמודדות עם בעיית ה-memory wall, והיא עשויה לשמש גם כדי לחשב מראש תוצאות branch-ים להשגת חיזוי מדויק יותר.

## קריאות ספקולטיביות

הרעיון המרכזי של קריאות ספקולטיביות הוא להקדים ביצוע של פעולות קריאה לזיכרון כך שהן יבוצעו במקביל לפעולות קודמות באותו מעבד. טכניקה זו מאפשרת לקריאות להסתיים מוקדם יותר, ובכך ייתכן שהן יסתיימו שלא בסדר התוכנית המקורי. מערכת פשוטה עוקבת אחר כך כדי לזהות אם ביצוע מקבילי זה עלול לגרום להפרות בעקביות הזיכרון. אם מתגלה הפרה כזו, הקריאה הספקולטיבית וכל החישובים התלויים בה מבוטלים מבוצעים מחדש. טכניקה זו מותאמת במיוחד למעבדים דינמיים בעלי יכולת חיזוי branch-ים, מכיוון שמנגנון ההחזרה לאחור במקרה של טעות דומה למנגנון ההחזרה שמופעל כשחיזוי branch מתגלה כשגוי.

הדרישות לשמירה על עקביות רציפה עלולות לשלול שימוש בטכניקות שמאיצות את פעולת המעבדים. במקרים מסוימים, המחיר של שמירה על עקביות כזו עשוי להאט את המעבד באופן שלא מצדיק את המאמץ.

חיזוי branch-ים דינמי מאפשר למעבד לצפות את ההתפתחויות הבאות בקוד ולהתחיל בביצוע פעולות מעבר ל-branch-ים שעדיין לא פתורים. ביצוע ספקולטיבי מנצל זאת בכך שהוא מאפשר למעבד לבצע הוראות מראש, עוד לפני שה-branch הספציפי נפתר.

בחלק זה מתואר כיצד ניתן ליישם ביצוע ספקולטיבי לפעולות קריאה במעבדים דינמיים. טכניקה זו רלוונטית במיוחד למעבדים שכבר כוללים מנגנוני החזרה לאחור עבור חיזוי שגוי של branch-ים.

#### תיאור טכניקת הביצוע הספקולטיבית

הרעיון מאחורי הביצוע הספקולטיבי הוא די פשוט: נניח שיש לנו שתי פעולות בתוכנית, u ו-v, כאשר u היא פעולה שדורשת זמן עיבוד ארוך ו-v היא פעולת קריאה. ונדרש שפעולת הקריאה v תתבצע רק לאחר השלמת הפעולה u. בטכניקת הביצוע הספקולטיבי, המעבד מניח או משיג ערך עבור פעולת הקריאה v עוד לפני ש-u מסתיימת וממשיך בביצוע יתר הפעולות. אם בסיום הפעולה u מתגלה שהערך של פעולת הקריאה v תואם לערך הנוכחי, הספקולציה מוצלחת והחישוב נחשב לנכון. המשמעות היא שגם אם v הייתה מתבצעת לאחר u, התוצאה הייתה זהה. לעומת זאת, אם הערך הנוכחי של v שונה מהערך הספקולטיבי, יש לבטל את החישובים שהיו תלויים בערך השגוי ולבצע אותם מחדש.

כדי ליישם סכימה כזו, נדרש מנגנון שמספק ערך ספקולטיבי עבור פעולת הקריאה, מנגנון שמזהה האם הספקולציה הצליחה, ומנגנון תיקון שמאפשר לבטל ולבצע מחדש חישובים במקרה של כישלון בספקולציה.

הגישה ההגיונית ביותר היא לבצע את פעולת הקריאה ולהשתמש בערך שהוחזר. במצב שבו פעולת הקריאה מתבצעת ב-cache, הערך יתקבל במהירות. במצב של פספוס ב-cache, למרות שהערך לא יתקבל מיד, הקריאה תבוצע במקביל לפעולות אחרות, בדומה למנגנון של prefetch. באופן כללי, ספקולציה על ערך מסוים אינה מועילה אלא אם ידוע שהערך מוגבל לטווח קטן, כמו למשל במקרים של פעולות נעילה.

באשר למנגנון הזיהוי, דרך בסיסית לזהות אם ערך ספקולטיבי שגוי היא לבצע את פעולת הקריאה מחדש בתנאים לא ספקולטיביים, ולבדוק את הערך המתקבל מול הערך הספקולטיבי. עם זאת, אם מנגנון הספקולציה מאחסן את הערך ב-cache, ניתן לעקוב אחרי טרנזקציות קוהרנטיות באותו מיקום כדי לאמת אם הערך הספקולטיבי נכון. כך, טכניקת הביצוע הספקולטיבית מאפשרת גישה אחת ל-cache עבור כל פעולת קריאה, בניגוד לשתי הגישות הנדרשות בטכניקת prefetch.

ניקח שוב פעם לדוגמה את הפעולות u ו-v. ויש דרישה שהשלמת הקריאה v תעוכב עד להשלמת u. הטכניקה הספקולטיבית מאפשרת להנפיק את הקריאה v מוקדם, והמעבד ממשיך עם הערך הספקולטיבי. אם מגיעה בקשה לעדכון או ביטול עבור המיקום של v לפני ש-u הסתיימה, זה מצביע על כך שהערך הספקולטיבי עשוי להיות שגוי. מנגד, היעדר הודעות invalidate או עדכון מרמז שהערך הספקולטיבי כנראה נכון. יש להתייחס גם להחלפות cache באופן נכון, משום שאם מיקום v יוחלף מה-cache לפני ש-u תסתיים, ייתכן שלא יתקבלו עוד בקשות invalidate ועדכון, והערך הספקולטיבי ייחשב לעתיק. במצב כזה, נדרש לחזור על הקריאה לאחר השלמת u כדי לאמת את הערך.

אם הערך הספקולטיבי מתברר כשגוי, מנגנון התיקון מבטל את כל החישובים שהתבססו עליו ומבצע אותם מחדש. מנגנון זה דומה למנגנון המשמש במעבדים עם branch prediction, בהם במצב של חיזוי שגוי מבטלים את ההוראות שבוצעו לאחר ה-branch ומבצעים את ההוראות הנכונות. באופן דומה, אם הערך הספקולטיבי שגוי, מבטלים את פעולת הקריאה ואת החישובים שבאו בעקבותיה ומבצעים אותם מחדש כדי להשיג תוצאה נכונה.

הטכניקה הספקולטיבית מתמודדת עם החסרונות של טכניקת השליפה המוקדמת בכך שהיא מאפשרת גישה לערכים ספקולטיבים שהם מחוץ לסדר. באמצעות ביצוע ספקולטיבי, ניתן להנפיק פעולות קריאה ברגע שהכתובת עבורן ידועה, ללא קשר למודל העקביות שבו המערכת תומכת.

### שילוב קריאה ספקולטיבית עם prefetch חומרה לכתיבה

שילוב טכניקות הקריאה הספקולטיבית עם prefetch חומרה לכתיבה מציע הזדמנות לשיפור ביצועים משמעותי על ידי חפיפת פעולות זיכרון, ללא תלות במודל הזיכרון הנתמך. התוצאה היא שיפור בביצועים עבור כל סוגי מודלי העקביות, כולל המודלים היותר חלשים. שיפור זה חשוב במיוחד מכיוון שמודלים רגועים נוטים להיות בעלי מודל תכנות מסובך יותר.

העיקרון המרכזי מאחורי טכניקות אלו הוא לשרת את הפעולות בהקדם האפשרי, מבלי להתחשב במגבלות של מודל הזיכרון. עם זאת, מכיוון שצריך לשמור על תקינות, שירות מוקדם (או ספקולטיבי) לא תמיד מועיל. כדי שטכניקות אלו יוכלו לשפר את הביצועים, ההסתברות לכך שערך שנשלף מראש או ערך ספקולטיבי יידחה (או יעודכן במקרה של קריאה ספקולטיבית) צריכה להיות נמוכה. ישנן מספר סיבות לכך שפסילות כאלה צפויות להיות נדירות. אם מיקומים שנשלפו מראש או ערכים ספקולטיביים נדחים באופן חופשי, זה תלוי האם עיכוב פעולות אלו חיוני להשגת ביצועים נכונים.

טכניקות קריאה ספקולטיבית ותחזיות prefetch חומרה לכתיבה מספקות יתרונות ביצועים גבוהים יותר כאשר ישנו תדירות גבוהה של פעולות שדורשות זמן עיכוב ארוך (כמו החמצות cache). כאשר פעולות עם זמן עיכוב ארוך אינן תכופות (כלומר, מספר רב של הוראות מפרידות בין כל החמצת cache), מגבלות על משאבי buffer מונעות לרוב מהמעבד לחפוף מספר פעולות עיכוב ארוך בשל יכולת ההסתכלות המוגבלת. עם זאת, יישומים כאלה בדרך כלל פועלים ביעילות והפחתת זמן העיכוב לתקשורת פחות חשובה.

המשמעות המרכזית של הטכניקות המוצעות היא שהביצועים של מודלי עקביות שונים מתקרבים זה לזה לאחר יישום טכניקות אלו. לכן, הבחירה במודל עקביות לתמיכה בחומרה נעשית פחות קריטית אם נבצע את הטכניקות הללו. העלות היא כמובן המורכבות הנוספת של החומרה הנדרשת ליישום. בעוד שטכניקת השליפה המוקדמת היא פשוטה יחסית לשילוב במעבדים מרובי cache קוהרנטיים, הטכניקה של ביצוע ספקולטיבי דורשת תמיכה בחומרה מתקדמת יותר. 


##### ביצוע ספקולטיבי של פעולות loads

כאשר מעבד מבצע פעולת load באופן ספקולטיבי ממיקום שנמצא ב-cache, הדבר עלול להוביל לטעינת שורת cache חדשה. פעולה זו עשויה גם לגרום לפינוי של שורת cache קיימת, מה שיכול להשפיע על הביצועים הכלליים של המערכת.

## OOTA

המונח OOTA מתאר מצב תיאורטי שבו קבוצת thread-ים מבצעת פעולות load מ-stores, כאשר כל store תלויה בערך המוחזר מה-load המתאימה. התופעה יוצרת מחזור OOTA שבו עשוי להיווצר ערך לא תקני או "יש מאין", אך זו לא התוצאה היחידה האפשרית.

בכדי למנוע את תופעת ה-OOTA, אשר עלולה להוביל לתוצאות שגויות או בלתי צפויות, יש להקפיד על מספר דברים:

1. **איסור על טעינת ערכים מכתיבות ספקולטיביות**: אסור להניח ערכים מכתיבות ספקולטיביות לקריאות שאינן ספקולטיביות. חומרה המבצעת אופטימיזציות ספקולטיביות עשויה ליצור מחזורי OOTA במהלך הביצוע הספקולטיבי, אך נדרשת לכך מנגנונים שמונעים ממחזורי OOTA ספקולטיביים להיכנס למצב מחויב.

2. **מניעת חשיפת ערכים ספקולטיביים**: ערכים המאוחסנים באופן ספקולטיבי אינם מורשים להיות נגישים לקריאות לא ספקולטיביות מ-thread-ים אחרים. כאשר מדובר ב-thread-ים מרובים שחולקים את אותה הליבה, ספקולציות הכוללות מספר thread-ים חייבות להיות מנוהלות באופן שיבטל את כל ההשפעות של ספקולציות אלה על כל ה-thread-ים המעורבים.

3. **הקפדה על סידור נכון של stores**: המעבדים בעולם האמיתי חייבים לסדר את ה-stores לאחר ה-loads המתאימים להם כדי למנוע תוצאות OOTA. כלומר, הכתיבות נדרשות להתבצע לאחר שהקריאות המתאימות הושלמו ומסופקות.

4. **אישור ספקולציות**: לפני ש-store מחויבת, יש לוודא שכל הספקולציות שה-store תלויה בהן אושרו. זאת אומרת, ה-store אינה נחשפת ל-thread-ים אחרים עד שכל הספקולציות שקשורות אליה אושרו. במערכות מסודרות חלש, כמו גם בתוכנה המשתמשת בלולאות השוואה והחלפה או בזיכרון טרנזקציית חומרה, יש לוודא שהספקולציות מאושרות לפני ביצוע ה-stores.

באופן כללי, ביצוע ספקולטיבי על ידי חומרה הוא עניין שכיח, אך הוא כרוך בצורך להמתין לאישור הספקולציות לפני שהכתיבות נחשבות כמחויבות או נגישות ל-thread-ים אחרים.

### ליבות ספקולטיביות - Speculative

ליבה שמבצעת הוראות לפי סדר התוכנית עשויה גם לבצע חיזוי branch-ים, מה שמאפשר להתחיל בביצוע הוראות עוקבות, כולל פעולות loads ו-stores, גם כאשר ייתכן שיהיה צורך לבטל את הפעולות הללו במקרה של חיזוי branch שגוי.

כאשר קריאות או כתיבות אלו מבוטלות, ניתן להתייחס אליהן כאל שליפות מוקדמות (prefetches) לא מחייבות, מכיוון שהן לא משפיעות על זיכרון עקבי. לדוגמה, אם קריאה מבוטלת, הליבה פשוט מסלקת את עדכון הרגיסטר, ומבטלת את כל ההשפעות התפקודיות של אותה קריאה, כאילו לא התרחשה בכלל.

ב-cache אין צורך לבטל את השליפות המוקדמות הלא מחייבות, מכיוון שהשליפה המוקדמת של הבלוק עשויה לשפר את הביצועים אם הקריאה תתבצע מחדש. כאשר מדובר בכתיבה, הליבה עשויה ליזום פעולת ReadUnique (בפרוטוקול AMBA CHI) לא מחייבת (שתתחיל את הבאת הבלוק), אך היא לא תתחייב לכתוב את הערך ל-cache עד שתהיה וודאות כי הפעולה אכן תתחייב.

### ליבות מתוזמנות דינמית

ליבות מודרניות רבות משתמשות בתזמון דינמי כדי לבצע הוראות שלא בסדר התוכנית המקורי, במטרה לשפר את הביצועים, בניגוד לליבות מתוזמנות סטטית, שחייבות לבצע הוראות בסדר תכנותי קפדני. מעבדים בעלי ליבה אחת המשתמשים בתזמון דינמי או בביצוע מחוץ לסדר צריכים להבטיח רק את תלות הנתונים האמיתית בתוך התוכנית. אבל, במעבדים מרובי ליבות, התזמון הדינמי מציב אתגר חדש - ספקולציות על עקביות זיכרון.

לדוגמה, כאשר ליבה מנסה לסדר מחדש באופן דינמי את הביצוע של שתי פעולות loads מהזיכרון, L1 ו-L2, ייתכן שהיא תבצע את L2 לפני L1 באופן ספקולטיבי, מתוך הנחה שהסידור מחדש לא ייחשף לליבות אחרות. סידור כזה עשוי לפגוע בעקביות זיכרון.

כדי להבטיח שתחזיות אלו נכונות, נדרשות בדיקות ספקולטיביות על עקביות זיכרון. Gharachorloo הציג שתי טכניקות לבדיקת התחזיות:

1. **בדיקת תקינות ה-cache לפני התחייבות (Commit)**: לאחר שהליבה מבצעת באופן ספקולטיבי את L2, אך לפני שהיא מתחייבת אליו, היא בודקת אם הבלוק שנגיש באופן ספקולטיבי עדיין נשאר ב-cache. כל עוד הבלוק נשאר ב-cache, הערך שלו לא ישתנה בין הביצוע הספקולטיבי לבין התחייבותו. הליבה עוקבת אחר הכתובת שנטענה על ידי L2 ומשווה אותה לבלוקים שפונו ולבקשות קוהרנטיות נכנסות. הודעת ReadUnique נכנסת מצביעה על כך שליבה אחרת ביצעה כתיבה, מה שמסמן שהקריאה L2 שהליבה ביצעה ספקולטיבית עשויה להיות שגויה, ולכן יש למחוק את הביצוע הספקולטיבי ולבצע אותו מחדש.

2. **ביצוע מחדש של ה-Load הספקולטיבי בעת התחייבות**: כאשר הליבה מתכוננת לבצע את הקריאה באופן סופי, היא מבצעת אותו מחדש ומשווה את הערך שנטען מחדש לערך שנטען בעבר באופן ספקולטיבי. אם הערך שהתקבל שונה מזה שהתקבל בביצוע הספקולטיבי, החיזוי היה שגוי. לדוגמה, אם הערך החדש של L2 שונה מהערך המקורי של L2, אז הסידור מחדש של פעולות ה-load הוביל לתוצאות שונות, ולכן יש לבטל את הביצוע הספקולטיבי.

#### ספקולציות לאחר פרישה

מעבדים משתמשים במבנה שנקרא store buffer כדי להסתיר את זמני ההשהיה הנובעים מפספוסי כתיבה. כאשר פעולה של store מתבצעת, היא פורשת מה-pipeline של המעבד אל ה-store buffer, משם היא מתנקזת למערכת ה-cache או הזיכרון. כך נמנע המעבד מלהתעכב. תהליך זה בטוח כאשר מדובר בליבה אחת, בתנאי שהפעולות הקריאה יבדקו ב-store buffer האם ישנן פעולות כתיבה בהמתנה לאותה כתובת. אבל, במערכות מרובות ליבות, כללי הסדר של עקביות זיכרון מגבילים שימוש פשוט ב-store buffer.

ליבות עם תזמון דינמי יכולות להסתיר חלק מהשהיית הפספוסים של פעולות ה-store, אך לא את כולן. כדי להסתיר יותר מהשהיית הפספוסים, הוצעו טכניקות אגרסיביות יותר שמבצעות ספקולציות מעבר לחלון ההוראות. הרעיון המרכזי הוא לפרוש באופן ספקולטיבי פעולות קריאה וכתיבה שמחכות לפספוסים, תוך שמירה על המצב הספקולטיבי של ההוראות הללו בנפרד.

אחת השיטות הנפוצות היא עיכוב בקשות קוהרנטיות. בשיטה זו, כאשר פעולת זיכרון צעירה שפרשה ויש פעולת זיכרון ישנה יותר שעדיין ממתינה, בקשות קוהרנטיות למיקום הזיכרון של הפעולה הצעירה מתעכבות עד שהפעולה הישנה יותר תפרוש. שיטה זו עלולה להוביל ל-deadlock, ולכן יש צורך במנגנונים קפדניים להימנע ממנו.

### תמיכה פשוטה יותר בספקולציות ליבה

במערכות שבהן יש מודלים חזקים לעקביות זיכרון, ליבה עשויה לבצע ספקולציות על פעולות קריאה לפני סדר התוכנית המקורי, גם אם הן עדיין אינן מוכנות להתחייב.


### Prefetch - Speculation

היכולת של מעבד לבצע הוראות באופן שאינו לפי סדרן המקורי מאפשרת לו להעביר הוראות שהתנגשויות ביניהן אינן מהוות בעיה. עם זאת, אף על פי שהמעבד אינו יכול להשתמש בערך שנמצא עדיין, הוא יכול להתחיל את העבודה על ההוראות בהתאם.

היתרון המרכזי של loads ספקולטיביות הוא בכך שהן מספקות את הערכים הנדרשים מוקדם יותר, ובכך מסייעות להסתיר את השהיות הנובעות מהמתנה לטעינה של נתונים מהזיכרון.

כאשר מדובר ב-load ספקולטיבי, המנגנון מבצע את פעולת הקריאה כך שהשהייה הקשורה לטעינה מוסתרת מהמעבד. טעינות ספקולטיביות מספקות יתרון משמעותי בכך שהן טוענות את הערכים ישירות אל הרגיסטר, ולא לתוך שורת ה-cache. היתרון הזה חשוב במיוחד כאשר ה-thread לא מתוזמן באופן תדיר או עלול להיתקל בעיכובים אחרים, שכן הערך לא יתפוס מקום בשורת ה-cache ויתפנה בעתיד.


### Branch Predictor

ה-Branch Predictor הוא מעגל דיגיטלי המיועד לנחש את הכיוון שבו יתבצע ה-branch לפני שהמיקום הסופי שלו יוכר באופן חד משמעי. תהליך זה נועד לשפר את הביצועים של המעבד על ידי צמצום הזמן שבו המעבד מחכה להחלטות לגבי קפיצות מותנות.

במידה ואין שימוש ב-branch prediction, המעבד נאלץ להמתין עד שהוראת הקפיצה המותנית תושלם בשלב הביצוע לפני שתוכל להתחיל לעבד את ההוראה הבאה ב-pipeline. ה-branch prediction פועל במטרה למנוע בזבוז זמן זה על ידי ניחוש אם הקפיצה המותנית צפויה להתבצע או לא. על פי התחזיות, ההוראות הנכונות מבוצעות באופן ספקולטיבי, כלומר, לפני שהכיוון הסופי של הקפיצה נקבע.

אם מתגלה מאוחר יותר שהתחזיות היו שגויות, ההוראות שבוצעו או התבצעו חלקית על פי התחזיות יבוטלו, וה-pipeline יתאפס ויתחיל מחדש עם ה-branch הנכון. תהליך זה כרוך בעיכוב, אך מאפשר לנצל בצורה יעילה יותר את משאבי המעבד ולשפר את ביצועיו הכוללים.

כאשר המעבד נתקל בהוראה מותנית, כמו הוראת branch, הוא עשוי להתחיל לבצע הוראות באופן ספקולטיבי, עוד לפני שידוע אם ההוראה הספציפית הזו באמת צריכה להתבצע. ביצוע מוקדם זה יכול לשפר את הביצועים, מכיוון שהתוצאה תהיה זמינה מיד ברגע שהתנאים יאשרו שהספקולציה הייתה נכונה.

### ספקולציה של טעינת נתונים במעבדים

מעבדים מודרניים מבצעים לעיתים ספקולציה ב-loads, כלומר הם מניחים מראש שיהיה צורך לטעון נתון מהזיכרון. במצב כזה, המעבד ינצל זמן שבו ה-bus לא בשימוש לטעינה מראש של הנתונים, גם אם הנקודה שבה יש לבצע את הטעינה לא הגיעה עדיין בזרימת ביצוע ההוראות. גישה זו מאפשרת להוראת load להסתיים במהירות רבה יותר מכיוון שלמעבד יש כבר את הערך המיוחל בהישג יד.

עם זאת, יתכן שהמעבד יגלה שלא היה צורך בטעינה זו, לדוגמה אם הוראת branch עקפה את ה-load. במקרה כזה, המעבד יכול לזרוק את הערך המיותר או לשמור אותו ב-cache לשימוש עתידי.

כאשר מניחים מחסום קריאה או מחסום תלות כתובת מיד לפני ביצוע ה-load, כל ערך שנאסף באופן ספקולטיבי יידרש לעבור בחינה מחדש, תלוי בסוג המחסום שנעשה בו שימוש.

### טעינת נתונים וזיכרון במעבדים

כאשר מעבד מבצע הוראת טעינה (L), הוא קודם כל בודק אם יש הוראות stores שנעשו קודם לכן, לאותו מיקום זיכרון, לפני הוראת ה-load בסדר התוכנית. אם יש הוראת store מתאימה, המעבד משתמש בערך של ה-store האחרון שנעשה (העונה על התנאים) כערך שהטעינה (L) מקבלת. אנו אומרים שהערך של ה-store הועבר (forwarded) ל-L.

אם אין הוראת store מתאימה לפני L, המעבד פונה לתת-מערכת הזיכרון כדי לטעון את הערך מהזיכרון. במצב זה, אנו אומרים ש-L מסופקת (satisfied) מהזיכרון. תת-מערכת הזיכרון מחזירה את הערך של ה-store האחרון למיקום זה, אם הוא כבר התפשט למעבד הנוכחי.

בפועל, התמונה עשויה להיות מורכבת יותר. למעבדים יש cache-ים מקומיים, ולכן הפצת ה-store למעבד משמעותה שהיא מתפשטת ל-cache המקומי של המעבד. cache מקומי יכול לקחת זמן לעבד את ה-stores שהוא מקבל, ולכן לא ניתן להשתמש ב-store כדי לספק את אחד מה-loads של המעבד עד שהוא עובר עיבוד. רוב הארכיטקטורות מאחסנות ב-cache-ים המקומיים בסדר FIFO, מה שגורם לעיכובים בעיבוד. עם זאת, בארכיטקטורות מסוימות, כמו Alpha, ה-cache-ים המקומיים מעוצבים בצורה שאינה FIFO, מה שיכול להוביל להתנהגות שונה.

חשוב לציין שהוראות טעינה עשויות להתבצע באופן ספקולטיבי ולעיתים ידרשו להופיע מחדש בנסיבות מסוימות. חלק ממודלי הזיכרון (כמו ה-LKMM) מתעלמים מהביצועים המוקדמים הללו, ומניח שפעולת הטעינה מתבצעת לפי הזמן האחרון שהיא הועברה או מסופקת.

### ספקולציות תלות זיכרון

מעבדים מוקדמים הפועלים בשיטת out-of-order ביצעו פעולות זיכרון בצורה לא ספקולטיבית בלבד. פעולות קריאה לא בוצעו עד שכל הכתובות של פעולות כתיבה קודמות היו ידועות, כך שניתן היה לקבוע בוודאות אם הקריאה תלויה בכתיבה מוקדמת ויש להמתין זמן נוסף. טכניקות של ספקולציה על תלות זיכרון מאפשרות למעבד לנחש אם קריאה תלויה בכתיבה קודמת, עוד לפני שהכתובות של הכתיבה ידועות, ובכך לסכן את עצמם בסידור שגוי שבו קריאה תתבצע לפני כתיבה שהיא תלויה בה.

מנבא תלות פשוט יכול לחזות שלרוב הקריאות אין תלות בכתיבות קודמות, מכיוון שבקוד בפועל רוב הקריאות אינן תלויות בכתיבות קודמות. מנבא מתקדם יותר עשוי להשתמש בהתנהגות העבר של הקריאה כדי לשפר את החיזוי.

במעבדים הממשיכים לבדוק את ה-store queue כדי לאתר תלות, ספקולציה לא תמיד נדרשת. כאשר מתבצעת קריאה, ייתכן שכל כתובות הכתיבה הקודמות כבר ידועות, כך שהמעבד יכול לדעת בוודאות אם יש תלות ללא צורך בספקולציה. ההתנהגות של קריאה שחזויה כתלויה אינה זהה בהכרח לקריאה שידוע כתלויה.


### כיצד סידור מחדש של Store-Load מסייע למעבדים

מעבדי x86 מודרניים מבצעים loads מוקדמות באופן ספקולטיבי לפני loads אחרות, גם כאשר יש cache miss. תהליך זה יכול להוביל לתוצאות שגויות אם המעבד מזהה שהעותק שלו של שורת ה-cache כבר לא תקף. כאשר מצב זה מתגלה, המעבד יזרוק את תוכן ה-reorder buffer כדי לחזור למצב עקבי ויתחיל לבצע מחדש את ההוראות מהשלב שבו הם נתקעו. בדרך כלל, תופעה זו מתרחשת כאשר ליבה אחרת משנה את שורת ה-cache, אך היא יכולה לקרות גם אם העיכוב התרחש בגלל טעינה ששגתה וטעינה מחדש לא נדרשה. חשוב לציין שלמעבדי x86 יש יכולת לבצע סידור מחדש של loads לפני stores בצורה חופשית.

אם לא הייתה אפשרות לסדר מחדש של Store-Load, המעבד היה יכול לבצע טעינות באופן ספקולטיבי, אך עדיין היה נדרש לבצע התחייבות לכתיבות מוקדמות יותר לפי התהליך הרגיל. ספקולציות טעינה יכולות להמשיך לעקוב אחרי כתיבות המאוחסנות ב-store buffer עד שהן פורשות.

במצב כזה, ההגבלה תהיה שטעינות לא יוכלו להתפרש עד שכל הכתיבות הקודמות יתממשו. הכתיבות הללו עשויות להישאר ב-store buffer לאחר הפרישה, מה שמונע מהן להיות ספקולטיביות נוספות. עם ROBs ענקיים ו-store buffers גדולים במעבדים מודרניים, המצב אינו נורא מאוד, אך הוא מהווה בעיה גדולה עבור מעבדים שמבצעים את הביצוע בסדר קבוע או עבור מעבדים עם יכולות ביצוע צנועות מחוץ לסדר.

אפילו עם יכולות ניהול עצומות מחוץ לסדר, תהליכי הספקולציה יכולים להיכנס לחלון זמן גדול שבו ה-CPU עלול להיתקל בעיכוב משמעותי אם יידרש להשליך את ה-pipeline ולזרוק את ה-ROB. בקוד מקביל, הניגש לזיכרון משותף, זה יכול להוביל לבעיות כמו false sharing, שבו משתנים עשויים להימצא באותה שורת cache, מה שמוביל לעונשים משמעותיים ולתופעות שליליות אחרות.

בנוסף, אם יש מעט כתיבות בקוד, אחת מהן שמחמיצה את ה-cache יכולה להימצא ב-store buffer במשך זמן רב, עד שיתקבל הנתון מזיכרון הראשי או עד שיתבצע עדכון עם בעלות בלעדית. במהלך עיכוב זה, עשויות לעבור מאות הוראות לפני שהכתיבה תתממש, מה שעלול לעכב את ההוראות החדשות מהן לא יכולה להיכנס ל-out-of-order back-end ולהיות מתוזמנות ליחידות ביצוע בזמן העיכוב.

למרות זאת, רוב הקוד לא מבצע הרבה כתיבות, ולכן ה-store buffer יתמלא במהירות. בארכיטקטורות עם סדר חלש שמאפשר סידור מחדש של Store-Store, הבעיה עם store-miss אינה משפיעה על כתיבות מאוחרות יותר.

מעבדי x86 אכן מבצעים טעינות מוקדמות באופן ספקולטיבי, ולכן ניתן להחיל את כלל Store-Load היפותטי וגם את כלל סידור Load-Load בפועל של x86.


## התמודדות עם ספקולציות

כדי להתמודד עם ספקולציות ארכיטקטורות מספקות כל מיני כלים והוראות מיוחדות.


### memory barriers

אחת הדרכים להתמודד עם ספקולציות של המעבד היא מחסומי זיכרון.
ב-ARMv8 יש מספר מחסומים שמיועדים להתמודד עם ספקולציות:


#### מחסום `DMB`

ההוראה `DMB` אינה מונעת ביצוע ספקולטיבי של קריאות עתידיות לזיכרון. במידה ובוצעה קריאה בזיכרון באופן ספקולטיבי, הליבה מחויבת למחוק את הנתונים הספקולטיבים מהרגיסטר. לאחר מכן, הליבה מחויבת לבצע מחדש את הקריאה מהזיכרון לאחר שצפתה וסיימה את כל הגישות הקודמות לזיכרון באופן מפורש.

#### מחסום ספקולציה (`SB`)

הוראת `SB` (Speculation Barrier) משמשת כמחסום המונע ביצוע ספקולטיבי של הוראות עד שהמחסום מושלם. כלומר, כל הוראה שנמצאת אחרי המחסום בסדר התוכנית אינה יכולה להתבצע ספקולטיבית במקרים שבהם הספקולציה עשויה להיחשף דרך ערוצים צדדיים. לדוגמה, אם מתבצעת הקצאה ספקולטיבית במבני ה-cache, הדבר יכול להצביע על ערך נתונים שנמצא בזיכרון או ברגיסטרים, וכתוצאה מכך לחשוף את הנתונים בערוצים צדדיים.

#### מחסום צריכת נתונים ספקולטיבי (`CSDB`)

הוראת `CSDB` (Consumption of Speculative Data Barrier) נועדה לשלוט בביצוע ספקולטיבי הנובע מחיזוי ערכי נתונים. כאשר הוראת `CSDB` מופיעה בקוד, אף פקודה (למעט הוראות branch) שמופיעה לאחריה בסדר התוכנית אינה יכולה להתבצע ספקולטיבית באמצעות תוצאות של ספקולציות שמתבצעות עבור הוראות הקודמות לה.

הוראת `CSDB` מגנה על התוכנית מפני הביצוע ספקולטיבי של הוראות כאשר ספקולציות קודמות עדיין לא נפתרו ארכיטקטונית. לדוגמה:

- ספקולציות על ערכי נתונים מכל סוג של הוראות.
- ספקולציות על הוראות (למעט branch) שקדמו ל-`CSDB` ולא נפתרו ארכיטקטונית.
- תחזיות מצב חיזוי SVE עבור כל הוראות SVE.


### הוראות אחרות
#### הוראת `CLRBHB` - ניקוי היסטוריית ה-branch-ים

ב-ARM קיימת ההוראה `CLRBHB` המשמשת לניקוי היסטוריית ה-branch-ים של ההקשר הנוכחי. הוראה זו מונעת שימוש במידע היסטורי של branch-ים שנוצר לפני ביצוע `CLRBHB` כדי לשלוט בביצוע של קוד המופיע לאחר מכן.

### linux kernel

למרות שלארכיטקטורות שונות יש מנגנונים למניעת קריאות ספקולטיביות, כגון הוראות `isb` ו-`isync` ב-ARM ו-PowerPC בהתאמה, הקרנל אינו כולל מתקן ייחודי למניעת קריאות ספקולטיביות בעקבות branch מותנה. אם יש צורך למנוע קריאות ספקולטיביות במקרה זה, ניתן להשתמש בהוראה `smp_rmb` כדי להבטיח סנכרון נכון בין ההוראות והקריאות למערכת הזיכרון.


## ספקולציות בארכיטקטורות

### ספקולציה ותחייבות של קריאות וכתיבות ב-Power

במערכת Power, ניתן לבצע קריאות וכתיבות באופן ספקולטיבי במצבים שונים:

1. **קריאות ספקולטיביות**: ניתן לבצע קריאות באופן ספקולטיבי, כלומר, לקרוא ערכים בזיכרון על סמך תחזיות מוקדמות. קריאה נחשבת "מסופקת" כאשר היא מקשרת (binds) את הערך שלה, כלומר, הערך שהתקבל מעודכן ומחובר לקריאה. קריאה נחשבת "מתחייבת" כאשר לא ניתן לשנות את הערך הזה יותר, והוא קבוע ואמין.

2. **כתיבות ספקולטיביות**: כתיבה ספקולטיבית מתבצעת כאשר הכתובת והערך שלה מחושבים, אולי באופן ספקולטיבי, ולכתיבה אסור להתפשט לקריאות מקומיות של thread-ים שונים. כתיבה נחשבת "מתחילה" כאשר הכתובת והערך שלה נקבעים, והכתיבה יכולה להתפשט ל-thread-ים אחרים כאשר היא מוכנה.


המפרט של מערכת Power מספק הגדרות ברורות לפעולות קריאה וכתיבה ספקולטיביות באמצעות המונחים `satisfy read events`, `initiate write events`, ו-`commit events`. זה מבטיח שכל פעולה ספקולטיבית נשמרת באופן מסודר ומבוקר, ושהערכים נחשבים סופיים כאשר הם לא יכולים להיות להשתנות מחדש.


### ספקולציות ב-AMD64


קריאה ספקולטיבית מותרת ומתרחשת כאשר המעבד מתחיל לקרוא מהזיכרון עוד לפני שברור שההוראה תושלם בהצלחה. לדוגמה, המעבד עשוי לחזות מראש את ביצועו של branch מסוים ולהתחיל לבצע את ההוראות שמגיעות בעקבותיו, מבלי לדעת אם החיזוי נכון. כאשר אחת מההוראות הללו כוללת קריאה לזיכרון, הקריאה היא ספקולטיבית. גם מילוי cache יכול להתבצע באופן ספקולטיבי.

לעומת זאת, כתיבה ספקולטיבית אינה מותרת. בדומה לכתיבה מחוץ לסדר, כתיבות ספקולטיביות אינן יכולות לרשום את תוצאותיהן לזיכרון עד שכל ההוראות הקודמות יושלמו לפי הסדר הנכון. במקרים כאלה, המעבד עשוי לשמור את תוצאות הכתיבה ב-buffer פרטי, שאינו נגיש לתוכנה, עד לרגע שבו ניתן לבצע את הכתיבה בפועל.

כאשר שורת cache נמצאת כבר במצב Modified, פגיעת (hit) כתיבה אינה משנה את מצבה. מעברי מצב ב-cache הנגרמים על ידי קריאות, בדיקות קריאה או בדיקות כתיבה, יכולים להתרחש בעקבות שליפה מוקדמת או ביצוע ספקולטיבי. במשפחת המעבדים 17h, מעבר למצב Modified אינו מתבצע באופן ספקולטיבי, אך עדיין אפשרי ש-cache יקבל נתונים כתובים מ-cache אחר באופן ספקולטיבי, מה שמוביל את השורה למצב Dirty. יישומים מסוימים עשויים לתמוך בתת-קבוצה של מצבי MOESDIF.


### ספקולציות ב-ARM

ספקולציה במעבדים מתארת מצב שבו ליבה מבצעת או מתחילה לבצע הוראה לפני שיש לה ודאות שההוראה הזו אכן צריכה להתבצע. היתרון בכך הוא שהמעבד עשוי לסיים את הביצוע מוקדם יותר אם יתברר שהספקולציה הייתה נכונה. דוגמאות לכך כוללות שימוש בביצוע מותנה בערכות ההוראות של Arm, או כאשר הליבה נתקלת ב-branch מותנה. במקרים כאלה, הליבה יכולה להתחיל לבצע באופן ספקולטיבי את ההוראה המותנית או את ההוראות שאחריה. במקרה שהספקולציה מתבררת כלא נכונה, הליבה חייבת לוודא שכל הסימנים לפעולה זו יימחקו.

במקרה של הוראות טעינת זיכרון, ספקולציות עשויות להיות מורכבות אף יותר. למשל, אם מתבצעת באופן ספקולטיבי הוראת load ממיקום בזיכרון הניתן ל-cache, זה עלול לגרום להעתקת אותו מיקום מהזיכרון החיצוני אל ה-cache, פעולה שעלולה לפנות שורת cache קיימת. מעבדים מודרניים מתקדמים אף יותר ועוקבים אחר דפוסי גישה לנתונים על מנת לנבא מראש את הכתובות הבאות שיידרשו, ובכך להכניס אותן ל-cache עוד לפני שההוראות המתאימות נכנסות ל-pipeline של המעבד.

המעבד מסוגל לגשת באופן ספקולטיבי למיקומי זיכרון המסומנים כרגילים. זה אומר שהוא עשוי לקרוא נתונים או הוראות מהזיכרון גם מבלי שהגישה תתבצע באופן מפורש בתוכנית, או לפני שהפניה המפורשת לזיכרון מתבצעת בפועל. גישות ספקולטיביות כאלה עשויות להתרחש כתוצאה מחיזוי של branch-ים, טעינה ספקולטיבית של שורות ב-cache, ביצוע קריאות לא מסודרות לזיכרון (out-of-order loads), או כתוצאה מאופטימיזציות חומרה נוספות.

בנוסף, המעבד עשוי לבצע גישה ספקולטיבית לזיכרון המסומן כרגיל בכל רגע נתון. לכן, בעת הערכה האם נדרשים מחסומים לזיכרון, יש לקחת בחשבון לא רק את הגישות המפורשות המתבצעות באמצעות הוראות load או store, אלא גם את הגישות הספקולטיביות שאינן מופיעות בתוכנית בצורה ישירה.

