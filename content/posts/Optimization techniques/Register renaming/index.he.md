+++
Sources = [
"https://en.wikipedia.org/wiki/Register_renaming",
"https://stackoverflow.com/questions/64141366/can-a-speculatively-executed-cpu-branch-contain-opcodes-that-access-ram/64148401#64148401",
"https://stackoverflow.com/questions/54876208/size-of-store-buffers-on-intel-hardware-what-exactly-is-a-store-buffer",
"https://arxiv.org/pdf/2310.13212",
"https://dl.acm.org/doi/pdf/10.1145/3524059.3532396",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-11"
categories = [

]
series = [

]
title = "Register renaming"
+++
## מבוא


בארכיטקטורת מחשבים, Register Renaming הוא טכניקה שמבצעת הפרדה בין רגיסטרים לוגיים לרגיסטרים פיזיים. כל רגיסטר לוגי מקושר לקבוצה של רגיסטרים פיזיים, וכאשר הוראת שפת מכונה מתייחסת לרגיסטר לוגי, המעבד ממפה אותו לרגיסטר פיזי ספציפי במהלך הביצוע. הרגיסטרים הפיזיים אינם נגישים ישירות, וניתן לגשת אליהם רק דרך השמות הקנוניים של הרגיסטרים הלוגיים.

טכניקה זו מאפשרת להתגבר על תלות כוזבת בנתונים הנובעת משימוש חוזר ברגיסטרים על ידי הוראות עוקבות שאין ביניהן תלות אמיתית. ביטול התלות הכוזבת מגביר את המקבילות ברמת ההוראה בזרם הפקודות, מה שמאפשר לנצל טכניקות כמו ביצוע על-סקלרי וביצוע מחוץ לסדר לשיפור הביצועים.

כאשר מספר הוראות מתייחסות לאותו מיקום בזיכרון כאופרנד, באמצעות קריאה (קלט) או כתיבה (פלט), ביצוען בסדר שונה מסדר התוכנית המקורי עלול להוביל לשלושה סוגי סכנות נתונים (data hazards).

במקום לעכב את הכתיבה עד להשלמת כל הקריאות, ניתן לשמור שני עותקים של המיקום: ערך ישן וערך חדש. קריאות שמתבצעות לפני הכתיבה יקבלו את הערך הישן, בעוד שקריאות המתבצעות לאחר הכתיבה יקבלו את הערך החדש. כך ניתן לשבור את התלות הכוזבת וליצור הזדמנויות נוספות לביצוע מחוץ לסדר. לאחר שכל הקריאות שהיו זקוקות לערך הישן הושלמו, ניתן למחוק אותו. זהו הרעיון המרכזי מאחורי שינוי שמות של רגיסטרים.

אפשר להפעיל שינוי שמות על כל דבר שנקרא ונכתב. למרות שהדיון מתמקד בעיקר ברגיסטרים כלליים, גם רגיסטרי דגלים וסטטוס, ואפילו ביטים סטטוס בודדים, עוברים לעיתים שינוי שמות.

שינוי שמות ניתן להחלה גם על מיקומי זיכרון, אם כי זה פחות נפוץ בהשוואה לשינוי שמות של רגיסטרים. דוגמה לכך היא ה-store buffer המובנה במעבד ה-Transmeta Crusoe, שהוא סוג של שינוי שמות של זיכרון.

הגדלת גודל הקוד היא חשובה כי כאשר קוד התוכנית גדול יותר, תדירות הפספוסים ב-cache ההוראות עולה, מה שגורם למעבד להיתקע בהמתנה להוראות חדשות.

## במעבדי intel

ה-back end כולל את ה-Renamer, אשר אחראי על הוצאת הוראות ל-scheduler. ה-scheduler שולח את ההוראות ליחידות הביצוע (execution units), אשר נגישות דרך execution ports.

כדי לאפשר עבודה במקביל של רכיבים שונים, ישנם buffers הממוקמים בין הרכיבים. לדוגמה, המפענח (decoder) מפרש הוראות קלט ומאחסן את ה-µops בתור פענוח ההוראות (instruction decode queue - IDQ). ה-Renamer שואב את ה-µops מה-IDQ, מבצע את המשימות הדרושות ומאחסן אותם ב-reorder buffer, תוך שהוא מוציא אותם גם ל-scheduler. כל רכיב ב-pipeline מסוגל לעבד מספר הוראות או µops בכל מחזור, בהתאם לרוחב העיבוד המקביל שלו. המספר המדויק של µops שעובדים על ידי רכיב מסוים במחזור תלוי במאפייני רכיב ה-pipeline ובמאפייני ה-µops המעובדים באותו מחזור.


ה-Renamer, הידוע גם כטבלת הקצאת משאבים (RAT - Resource Allocation Table), ממפה רגיסטרים ארכיטקטוניים לרגיסטרים פיזיים. בנוסף, הוא מקצה משאבים להוראות loads ו-stores ולפורטי ביצוע עבור ה-µops.

ה-Renamer מקבל µops מ-IDQ, מאחסן אותם ב-Reorder Buffer, ומנפיק אותם למתזמן (scheduler). מספר ה-µops המרבי שה-Renamer יכול לטפל בהם בכל מחזור נקרא "רוחב ההנפקה" (issue width).

ה-µops נשארים ב-Reorder Buffer עד שהם מוכנים להיפלט. µop מוכן להיפלט אם הוא סיים את ביצועו וכל ה-µops המוקדמים יותר בסדר התוכנית מוכנים להיפלט גם הם.

ה-Renamer מסוגל לבצע ישירות סוגים מסוימים של µops, כמו הוראות move של רגיסטרים (register moves), ה-NOPs או הוראות שמייצרות תמיד ערך של 0 ברגיסטר היעד. הוראות כאלה מאוחסנות ב-Reorder Buffer אך אינן נשלחות ל-scheduler. דוגמה לכך היא פעולה כמו XOR של רגיסטר עם עצמו.

גודל ה-Reorder Buffer, רוחב ההנפקה, מספר ההוראות שניתן לפרק בכל מחזור, והאם יש לשנות את שמו של הרגיסטר הגבוה של 8 סיביות בנפרד מהרגיסטר הנמוך הם פרמטרים של המודל שלנו.

עבודות קודמות הגדירו אילו פורטים ניתן להקצות ל-µop, לא היה ברור כיצד ה-Renamer מבצע את הבחירה בפועל בזמן הריצה.

ה-loop stream detector מזהה מקרים שבהם µops של לולאה מתאימים באופן מלא ל-IDQ. במצבים כאלה, הוא "נועל" את ה-µops בתוך ה-IDQ ומזרים אותם באופן רציף ל-Renamer מבלי להמתין למפענחים או ל-DSB.

ה-Renamer שואב את ה-µops מה-IDQ ומנפיק אותם ל-scheduler. הוא גם אחראי על הקצאת משאבים להוראות load ו-store ועל הקצאת execution ports ל-µops. מספר ה-µops שניתן להנפיק בכל מחזור מוגבל לרוחב ההנפקה של המיקרו-ארכיטקטורה.

ה-Micro-fused µops, אשר מפוצלים על ידי ה-Renamer, נקראים unlaminated µops לאחר הפיצול. הם נשלחים כשתי µops ל-scheduler.

ה-Renamer מקצה כל µop לאחת מה-execution ports האפשריות, תוך ניסיון לפזר את ה-µops באופן שווה בין הפורטים השונים.

ה-store-address וה-store-data יכולים לפעול בכל סדר, כאשר השלב המוכן ראשון מתבצע ראשון. שלב ה-allocate/rename, שמקצה uops מ-frontend ל-ROB ול-RS ב-backend, גם מקצה buffer לטעינה או לאחסון uops במהלך ההנפקה.

ה-Store Buffer הוא למעשה מבנה מעגלי: ערכים המוקצים על ידי ה-frontend (במהלך שלבי ה-alloc/rename ב-pipeline העיבוד) ומשוחררים כאשר ה-store מתחייב ל-L1d cache. ה-cache L1d נשמר קוהרנטי עם ליבות אחרות באמצעות פרוטוקול MESI.

## ה-store buffer כ-renaming

אפשר לחשוב על ה-store buffer כאל סוג של register renaming או יותר נכון להתנהגות ספציפית שלרוב משוייכת ל-store buffer וזה ה-forward buffer.

ה-forward buffer מאפשר למעבד לראות ערכים שהוא כתב ל-store buffer אבל עדיין בביצוע ועוד לא הושלמו, וזה בעצם סוג של ניתוק התלות למיקום ספיציפי עד להשלמת פעולת הכתיבה.
