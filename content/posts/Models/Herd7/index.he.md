+++
Sources = [
"https://www.joelfernandes.org/resources/lkmm_herd7.pdf",
"https://diy.inria.fr/doc/herd.html",
"https://lwn.net/Articles/720550/",
"https://pages.cs.wisc.edu/~markhill/papers/primer2020_2nd_edition.pdf",
"https://github.com/torvalds/linux/blob/master/tools/memory-model/Documentation/recipes.txt",
"https://en.wikipedia.org/wiki/Instruction_scheduling",
"https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/herd.html",
"https://github.com/torvalds/linux/blob/master/tools/memory-model/Documentation/litmus-tests.txt",
"https://diy.inria.fr/doc/diy.pdf",
"http://www0.cs.ucl.ac.uk/staff/j.alglave/papers/toplas21.pdf",
"https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/StrongModel.html",
"https://diy.inria.fr/doc/litmus.html",
"https://diy.inria.fr/linux/long.pdf",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-11"
categories = [

]
series = [

]
title = "Herd7"
+++








## מבוא

אחת מהשיטות לפורמליזציה של מודל זיכרון היא ליצור תיאור מופשט שמתאר את האופן שבו מערכת פועלת בצורה פנימית. לאחר מכן, ניתן למנות את כל התוצאות האפשריות שנובעות מהפעולה המופשטת הזו. שיטה נוספת היא להגדיר את האילוצים שמטיל מודל הזיכרון בעזרת אקסיומות לוגיות, ולמיין את כל התוצאות האפשריות שמתאימות לאילוצים הללו, הכלי herd פועל לפי הגישה הזו.

הכלי herd7 נועד לבדוק האם ביצועי זיכרון מסוימים, כולל תרחישים לא רצויים, יכולים להתרחש בתוכניות מקבילות בהתאם למודל זיכרון מוגדר. חשוב לציין כי herd7 עצמו אינו מתעסק ישירות בדרך שבה תוכניות רצות בפועל; הוא מתמקד אך ורק באימות התאמת הביצועים למודל הזיכרון שניתן לו.

כל תרחיש אפשרי של סדר גישה לזיכרון בתוכנית נקרא מועמד לביצוע (candidate execution). על מודל הזיכרון להגדיר אילו מהמועמדים האלו מותרים ואילו אינם מותרים. כלומר, מודל הזיכרון נותן הנחיות ל-herd7 לגבי אילו ביצועים יש לדחות ואילו נחשבים תקפים.

באמצעות herd7, ניתן גם ליצור גרפים מורכבים שממחישים את הקשרים בין הגישות לזיכרון בתוכניות מבחן לקמוס (litmus tests). גרפים אלה מאפשרים הבנה מעמיקה יותר של אופן ההתנהגות של גישות זיכרון במקביל.

מודל הזיכרון ב-herd7 מופשט במובן שהוא אינו מתאר את היישום המדויק של מעבד מסוים, אלא מספק קבוצה של כללים ומאפיינים על הסדר והלוגיקה של גישות הזיכרון בתוכנית.

הכלי herd פועל על ידי ייצוג האילוצים שמגדיר מודל הזיכרון באמצעות מערכת של אקסיומות לוגיות. על סמך אקסיומות אלה, herd מנתח את כל התוצאות האפשריות שעומדות בתנאים שהוגדרו במודל הזיכרון.

הקלט ל-herd הוא מבחן לקמוס (litmus test), שהוא קטע קטן של קוד לצד קביעה (assertion). הפלט של herd מראה האם מודל הזיכרון מאפשר ביצוע של קוד זה באופן שיביא לכך שהקביעה תהיה נכונה.

### מחזורים והגבלות

מחזורים (cycles) בזמן ביצוע הוראות, הם אינם אפשריים, בגלל שהזמן מסודר באופן ליניארי (ביקום שלנו, אם כי ייתכן שיש פתרונות אחרים למשוואות השדה של איינשטין שאינם מחויבים לכך). חלק מתפקידו של מודל הזיכרון הוא לקבוע את התנאים שבהם יש לבצע הוראה אחת לפני השנייה ולבחון אם קיימים מחזורים שנוצרו בתהליך. אם לא קיים מחזור כזה, ניתן למצוא סדר ביצוע לכל ההוראות שמספק את דרישות הסדר של מודל הזיכרון, לדוגמה על ידי ביצוע מיון טופולוגי. אם הסדר הפוטנציאלי של הביצוע אינו מפר את הדרישות האחרות של מודל הזיכרון, ניתן להוכיח כי הקביעה של מבחן הלקמוס עשויה להתקיים.

לחומרת המחשב יש לרוב הגבלות נוספות שאינן נכללות בתיאורים של מודלי הזיכרון. מעצבי מעבדים לרוב לא מיישמים את כל ההתנהגויות המותרות על ידי ארכיטקטורה. העובדה שמודל זיכרון טוען כי ניתן לקיים את ה-assertion של מבחן לקמוס מסוים אינה מבטיחה שזה יקרה בפועל בכל מחשב נתון. דוגמה לכך היא ש-store buffers מוגבלים הנמצאים בחומרה אמיתית מונעים מהחומרה לבצע את כל סידורי הכתיבה מחדש שמודלי זיכרון בדרך כלל מתירים. יתרה מכך, ייתכן שמעצבי מעבדים יישמו בטעות התנהגויות שאסורות על ידי ארכיטקטורה (הידוע גם בשם silicon bug או CPU erratum).

יש קשר הדוק בין סידורים לקיומם של מחזורים: כאשר אירועים מסוימים מוגדרים להיות מסודרים באופן מסוים, הסדר הזה לא יכול להכיל מחזור. אם קשר בין אירועים שונים אינו מכיל מחזורים, אז ניתן לסדר את האירועים הללו באופן עקבי. לכן, אם נצליח להגדיר במדויק אילו הוראות יש לבצע לפני אחרות בקוד, נוכל לפתח מודל פורמלי המגדיר את ערבויות סדר הביצוע באמצעות מחזורים בין הוראות. יתרה מכך, מודל זה יכול לשמש כבסיס לפיתוח כלי המנתח מבחני לקמוס בעיית סידור הביצוע. ניתן גם להשתמש באותה גישה כדי לתאר דרישות סדר אחרות של מודל הזיכרון.
## litmus test

מבחני לקמוס הם רצפי קוד פשוטים הפועלים במקביל (multithreading) ומופשטים מצורות סנכרון שונות. ההתנהגות שמודלי הזיכרון מגלים במהלך מבחנים אלו יכולה לספק תובנות חשובות למתכנתים ב-low level. לדוגמה, מבחנים אלה עשויים לחשוף את הצורך במחסומי זיכרון מסוימים כדי להשיג את ההתנהגות הרצויה במערכת. בנוסף, מבחני לקמוס לפעמים משמשים במדריכי ספקי מעבדים כדי להסביר את המאפיינים של מודל עקביות הזיכרון, וכך מספקים הקשר נוסף להבנת המערכת.

עם זאת, למרות שמבחני לקמוס מציעים דרך טובה להעביר אינטואיציה לגבי כיצד מודלי זיכרון פועלים, הם אינם יכולים לשמש בדרך כלל כמפרט מקיף ומלא של מודל הזיכרון. זאת מכיוון שהם עשויים להשאיר חלק מההתנהגויות הפוטנציאליות, אשר אינן מכוסות על ידי מבחנים אלו, בלתי מוגדרות.


כדי להבטיח שתלות בין אירועים נשמרת נבנה גרף תלות, גרף זה הוא גרף מכוון שבו כל קודקוד מייצג אירוע, וקיים קצה מ-`E1` ל-`E2` כשאירוע `E1` חייב להתרחש לפני אירוע `E2` עקב תלות כלשהי. בהנחה שהתלות בתוך הלולאה נשמרת, גרף התלות הוא גרף מכוון א-ציקלי (DAG). כל סדר טופולוגי של גרף זה נחשב תקף עבור האירועים.
### מבנה של מבחן לקמוס

כל פונקציה (המייצגת תהליך או thread) במבחן הלקמוס וניתן להעניק לפונקציה שם לפי בחירתך, כל עוד השם מתחיל באות `P` ואחריה מופיע מספר מזהה של המעבד, כאשר המספור מתחיל מאפס ונמשך ברציפות.

המוסכמה היא ששמות של משתנים מקומיים מתחילים באות `r`, שכן משתנים אלה נחשבים כמאוחסנים ברגיסטרים של המעבד.

משתנים גלובליים מועברים לפונקציות כפרמטרים, ושמותיהם של הפרמטרים חשובים: הם חייבים להיות תואמים לשמות המשתנים הגלובליים המתאימים.
### ביטוי `exists`

ביטוי הקביעה `exists` משמש להערכת המצב הסופי של המערכת לאחר ביצוע כלל הקוד במבחן, מצב סופי זה נבדק לאחר שכל התהליכים הסתיימו, וכל הפניות הזיכרון ומחסומי הזיכרון שלהם התפשטו והתעדכנו בכל חלקי המערכת.
#### תווים מיוחדים בשימוש ב-`exists`:

- תו `=` בודד בתוך ביטוי `exists` משמש כאופרטור שוויון, ולא כהצהרה או השמה.
- רצף התווים `/\` מייצג את האופרטור הלוגי "או" (OR), והוא שקול לסימון המתמטי `∨` ב-ASCII.
- רצף התווים `\/` מייצג את האופרטור הלוגי "וגם" (AND), והוא שקול לסימון המתמטי `∧` ב-ASCII.
- התו `~` מייצג שלילה (NOT).

הכלי herd מנתח ומחזיר תשובה האם הביטוי הלוגי מוערך כאמת עבור כל האפשרויות, חלקן, או אף אחת מהתוצאות האפשריות של קטע הקוד.

## שפת cat
שפת cat מציעה דרך לייצג מודלי זיכרון, והיא עושה זאת על ידי קבוצות של אילוצים על מועמדים לביצוע כמו אילוץ של איסור מחזורים. המפרט בשפה זו מוגדר במונחים של קבוצות ויחסים הכוללים אירועי גישה לזיכרון, מחסומים ו-thread-ים. לצורך העניין, כל מעבד במבחן לקמוס מתייחס ל-thread ספציפי.

שפת cat משמשת במקרים נפוצים מודלי זיכרון ואפילו ההגדרה הרשמית של המודל המקבילות המובטחת על ידי ארכיטקטורת Arm הוא המודל cat שמופץ כחלק מחבילת הכלים herd+diy.
וברור שגם מודל הזיכרון הרשמי של הקרנל בנוי בשפת cat.

### קובצי Bell ו-Cat

שני הקבצים, Bell ו-Cat, בנויים מהצהרות שנכתבות בשפת cat, ו-herd מתייחס אליהם באופן כמעט זהה. ההבדל העיקרי הוא שקובץ Bell רשאי להכיל הצהרת הוראות, בעוד שקובץ Cat אינו רשאי להכיל אותן.

### הצהרת `instructions`

הצהרת `instructions` מגדירה תגיות שניתן להוסיף כדקורטור (decorator) לפעולות בסיסיות. לדוגמה, הצהרה כזו עשויה להוסיף תג למחסום זיכרון בשם `mb`, דבר המצביע על כך שהפעולה המדוברת היא מחסום זיכרון מלא (למשל ב-LKMM).

בדרך כלל, קובץ Bell משמש לקוד המשותף בין מספר מודלים של זיכרון, כאשר לכל מודל יש קובץ Cat נפרד.

### יחס co וחישוב סדרי כתיבה

בניגוד ליחסים po ו-rf, יחס co אינו מובנה ויש לחשב אותו במפורש בהתאם למודל הזיכרון שבו משתמשים. חישוב יחס זה מתבצע באמצעות קובץ ייעודי בשם `cos.cat`, שנכלל בתחילת קובץ ה-Cat של המודל. חישוב יחס co מחייב ניסוי של כל הסדרים האפשריים של כתיבות למשתנה מסוים, מה שמוביל להוצאה חישובית ניכרת ואקספוננציאלית.

### שימוש בקבוצות ויחסים ב-herd

הכלי herd מתבסס על סטים (sets) של אירועים ויחסים (relations) בין אותם אירועים. כל יחס מוגדר כאוסף של זוגות סדורים של אירועים, כאשר כל זוג סדור מייצג קישור מהאירוע הראשון ביחס לאירוע השני. שפת cat, המשמשת בקבצי Bell ו-Cat, עשירה באופרטורים שמאפשרים לבנות ולבדוק סטים ויחסים כאלה, מה שמעניק גמישות בבניית מודלים מורכבים לניתוח הזיכרון.

### שימוש בסטים מובנים ב-herd

ל-herd יש מספר סטים מובנים מראש שמשמשים לסיווג אירועים, וכל אירוע שנוצר בתוכנית מתווסף אוטומטית לסטים הרלוונטיים.

| Name  | Contents                 | Comment                               |
| ----- | ------------------------ | ------------------------------------- |
| `R`   | Read events              |                                       |
| `W`   | Write events             |                                       |
| `IW`  | Initial Write events     | כתיבה שקובעת את הערך ההתחלתי של משתנה |
| `FW`  | Final Write events       | ערכים שנבדקים בקביעה הסופית           |
| `M`   | Memory access events     | כמו `R \| W`                          |
| `B`   | Branch events            |                                       |
| `RMW` | Read-Modify-Write events | האירועים המרכיבים של הוראת RMW אטומית |
| `F`   | Fence events             | ידוע גם כאירועי Barrier               |
| `_`   | All events               | wildcard (תו כללי)                    |

#### אירוע RMW
במעבדים הוראות מסוג RMW פועלות גם כקריאה וגם ככתיבה. עם זאת, ב-herd, הוראות אלה מיוצגות באופן פנימי על ידי אירוע קריאה שלאחריו מתבצעת כתיבה נפרדת. (כך מתנהגת גם החומרה).

הקשר rmw משמש לקישור בין קריאה ספציפית של פעולת RMW לבין הכתיבה המתקיימת לאחר מכן לאותו מיקום זיכרון.

#### אירוע IW
הערך ההתחלתי של מיקום בזיכרון נחשב כאילו נכתב על ידי פעולת כתיבה דמיונית ראשונית (initial write), אשר מופעלת על ידי מעבד נפרד לפני שהתוכנית הראשית מתחילה לפעול. כתיבה ראשונית זו, שמסמנת את הערך ההתחלתי של הזיכרון, מסומנת בתוכנה herd כ-`IW`.

כתיבה ראשונית אינה נוצרת על ידי הוראות הבדיקה, אלא על ידי מכונות herd7.

אתחול של משתנה תמיד נחשב לכתיבה הראשונה בסדר הקוהרנטיות עבור כל משתנה.

#### אירוע FW
כתיבה סופית (final write) יכולה להיווצר על ידי הוראות תוכנית, וכאשר היא נוצרת כך, היא חייבת להיות מסודרת בסדר קפדני. כתיבה סופית מתייחסת ככתיבה לקריאה דימיונית שמתבצעת לאחר סיום הפעלת התוכנית, והכתיבה הסופית זמינה כ-`IW`.

### הגדרת תגיות וסטים בקובץ Bell

באמצעות ההצהרות `enum` ו-`instructions`, קובץ Bell יכול להגדיר רשימה מסודרת של תגים, ולהורות שכל הוראות מסוג מסוים חייבות להיות מסומנות עם אחד מהתגים הללו. לאחר מכן, herd יוצר סט עבור כל תג. שם הסט הוא שם התג עם האות הראשונה באות גדולה, והוא יכיל את כל האירועים שנוצרו מהוראות שסומנו בתג המתאים.

לדוגמה, בקוד cat הבא (מתוך הקבצים של ה-LKMM):

```ocaml {linenos=inline}
enum Accesses = 'once || 'release || 'acquire || 'deref
instructions R[{'once,'acquire,'deref}]
```

הקטע הזה מגדיר קבוצת תגים בשם `Accesses`, שמכילה את התגים `once`,  `release`,  `acquire` ו-`deref`. בנוסף, הוא קובע שכל הוראות קריאה (`R`) חייבות להיות מסומנות עם אחד מהתגים `once`, `acquire`, או `deref`. כתוצאה מכך, herd ייצור מספר סטים: לדוגמה, הסט `Once` יכיל את כל האירועים התואמים להוראות המסומנות בתג `once`, והסטים `Acquire`, `Release` ו-`Deref` יכילו אירועים שנוצרו מהוראות עם התגיות המקבילות.

### הגדרת אירועים

את האירועים מהסוגים השונים והתיוג שלהם מגדירים בצורה הבאה (מתוך ה-LKMM ב-`linux-kernel.def`):

```ocaml {linenos=inline}
READ_ONCE(X) __load{once}(X)
```

כלומר מוגדרים מספר דברים:

- השם שם האירוע הוא `READ_ONCE`
- הוא אירוע קריאה שמסומן בעזרת `__load`
- האירוע מתויג עם התג `once` (שמוגדר ב-`linux-kernel.bell`)
- האירוע מקבל פרמטר `X`

### יחסים מובנים ב-herd

בנוסף לסטים, herd מגיע עם מבחר יחסים מובנים המאפשרים ניתוח של יחסים בין אירועים. חלק מהיחסים הללו כבר הוזכרו קודם, והם מהווים את הבסיס לניתוח תלות, סדרי גישה ויחסים בין פעולות כתיבה וקריאה בזיכרון.


| Name | Relation           | Comment                                                                                |
| ---- | ------------------ | -------------------------------------------------------------------------------------- |
| 0    | Empty              | יחס ריק, אינו מכיל קישורים                                                             |
| id   | Identity           | מקשר כל אירוע לעצמו                                                                    |
| int  | Internal           | מקשר אירועים שנמצאים באותו thread                                                      |
| ext  | External           | מקשר אירועים שנמצאים ב-thread-ים שונים                                                 |
| loc  | Location           | מקשר אירועי גישה לזיכרון המכוונים לאותו משתנה                                          |
| rf   | Reads-From         | מקשר אירוע כתיבה לכל אירוע קריאה שטוען את הערך המאוחסן בכתיבה זו                       |
| rmw  | Read-Modify-Write  | מקשר את אירועי הקריאה והכתיבה של הוראת RMW                                             |
| po   | Program Order      | מקשר אירועים באותו thread, בסדר שהם מתרחשים בזרם ההוראות (instruction stream)          |
| addr | Address dependency | מקשר אירוע קריאה לכל אירוע גישה לזיכרון שכתובת היעד שלו תלויה בערך הנטען על ידי הקריאה |
| ctrl | Control dependency | מקשר אירוע קריאה לכל האירועים שמתבצעים באופן מותנה בהתאם לערך שנטען על ידי הקריאה      |
| data | Data dependency    | מקשר אירוע קריאה לכל אירוע כתיבה המאחסן ערך שתלוי בערך הנטען על ידי הקריאה             |

### ספריות ויחסים נוספים ב-herd

הכלי herd כולל ספריות סטנדרטיות כגון `stdlib.cat` ו-`cos.cat`, והן מספקות הגדרות של יחסים נוספים שניתן להשתמש בהם כאילו הם מובנים.

יחסים אלה מרחיבים את יכולות ניתוח התוכנית ביחסים נפוצים:


| Name   | Relation                 | Comment                                                                                                                                    |
| ------ | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------ |
| po-loc | קשר po עבור אותו מיקום   | קישור אירועי גישה לזיכרון המכוונים לאותו משתנה, לפי סדר התוכנית; זהה ל-`po & loc`                                                          |
| rfe    | external reads-from      | קשר rf מוגבל לזוגות גישה ב-thread-ים שונים; זהה ל-`rf & ext`                                                                               |
| rfi    | internal reads-from      | קשר rf מוגבל לזוגות גישה באותו thread; זהה ל-`rf & int`                                                                                    |
| co     | coherence order          | הסדר הכולל של כל הכתיבה לכל משתנה                                                                                                          |
| coe    | external coherence order | קשר co מוגבל לצמדי כתיבה ב-thread-ים שונים; זהה ל-`co & ext`                                                                               |
| coi    | internal coherence order | קשר co מוגבל לצמדי כתיבה באותו thread; זהה ל-`co & int`                                                                                    |
| fr     | from-read                | מקשר אירוע קריאה לכל אירוע כתיבה עבור אותו משתנה שמגיע אחרי (בסדר הקוהרנטיות של המשתנה) הכתיבה שממנו קורא אירוע הקריאה, זהה ל-`rf^-1 ; co` |
| fre    | external from-read       | קשר fr מוגבל לצמדי גישה ב-thread-ים שונים, זהה ל-`fr & ext`                                                                                |
| fri    | internal from-read       | קשר fr מוגבל לזוגות גישה באותו thread, זהה ל`fr & int`                                                                                     |

### חישוב קבוצות ויחסים בקבצי Bell ו-Cat
קבצי Bell ו-Cat מסוגלים לחשב קבוצות ויחסים באמצעות פונקציות ואופרטורים שמסופקים על ידי שפת cat ועל ידי הספריות המצורפות. אופרטורים אלה מאפשרים עבודה עם מבנים לוגיים, קבוצות ויחסים.

הערה:
	בטבלה הבאה האופרטורים בעלי העדיפות הגבוהה יותר ממוקמים גבוה יותר בטבלה


| Operator      | Operation                                                   | Example                                                                                                                                                                                         | Applicability          |
| ------------- | ----------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------- |
| `domain`      | ה-domain של היחס                                            | האופרטור `domain(x)` מחשב את קבוצת כל האירועים שהם ההתחלה של קישור ב-x                                                                                                                          | חל על יחס, מניב קבוצה  |
| `range`       | ה-range של היחס                                             | האופרטור `range(x)` מחשב את קבוצת כל האירועים שהם הסוף של קישור ב-x                                                                                                                             | חל על יחס, מניב קבוצה  |
| `fencerel`    | מקשר אירועים שמופרדים על ידי fence (סוג ה-fence הוא הערך x) | האופרטור `fencerel(x)` מחשב את היחס המורכב מכל זוגות האירועים כאשר הראשון נמצא לפני (בסדר התוכנית) האירוע בקבוצה x והשני אחריו; זהה ל-`(po & (_ * x)) ; po`                                     | חל על קבוצה, מניב יחס  |
| `[]`          | מחזיר את יחס הזהות מהסט שיתקבל כקלט                         | האופרטור `[x]` מחשב את יחס הזהות המוגבלת לאירועים בסט x                                                                                                                                         | חל על קבוצה, מניב יחס  |
| Postfix `^-1` | היפוך (Inversion)                                           | האופרטור `x^-1` מחשב את היחס המתקבל על ידי היפוך של כל הקישורים ב-x                                                                                                                             | חל על יחס              |
| Postfix `?`   | סגירה רפלקסיבית                                             | האופרטור `x?` מחשב את היחס המורכב מכל זוגות האירועים שניתן לחבר באמצעות שרשרת של קישורים מ-x באורך 0 או 1; זהה ל-`id \|x`                                                                       | חל על יחס              |
| Postfix `+`   | סגירה טרנזיטיבית                                            | האופרטור `x+` מחשב את היחס המורכב מכל זוגות האירועים שניתן לחבר באמצעות שרשרת קישורים מ-x באורך 1 או יותר; זהה ל-$$\text{x} \vert \text{(x;x)} \vert \text{(x;x;x)} \vert ...$$                 | חל על יחס              |
| Postfix `*`   | סגירה רפלקסיבית טרנזיטיבית                                  | האופרטור `x*` מחשב את היחס המורכב מכל זוגות האירועים שניתן לחבר באמצעות שרשרת קישורים מ-x באורך 0 או יותר; זהה ל-`id \| x \| (x;x) \| (x;x;x) \| ...`                                           | חל על יחס              |
| Prefix `~`    | המשלים (complement)                                         | האופרטור `~x` מחשב את היחס (או הקבוצה) המורכב מכל הקישורים (או האירועים) שאינם ב-x                                                                                                              | חל על יחס או קבוצה     |
| Infix `*`     | מכפלה קרטזית                                                | האופרטור `x * y` מחשב את היחס המורכב מכל הקישורים מאירוע בסט x לאירוע בקבוצה y. מכפלה קרטזית של קבוצות אירועים (`x * y`): תהליך המייצר זוגות מכל הקומבינציות האפשריות של האירועים משתי הקבוצות. | חל על קבוצות, מניב יחס |
| `\`           | הפרש (difference)                                           | האופרטור `x \ y` מחשב את היחס (או הקבוצה) המורכב מכל הקישורים (או האירועים) ב-x שאינם נמצאים ב-y.                                                                                               | חל על יחסים או קבוצות  |
| `&`           | חיתוך (Intersection)                                        | האופרטור `x & y` מחשב את היחס (או ה-set) המורכב מכל הקישורים (או האירועים) גם ב-x וגם ב-y. ביצוג מתמטי `∩`                                                                                      | חל על יחסים או קבוצות  |
| `;`           | רצף (Sequencing)                                            | האופרטור `x ; y` מחשב את היחס המורכב מכל הקישורים a⟶c כך שבאירוע מסוים b, היחס x מכיל a⟶b ו-y מכיל b⟶c                                                                                          | חל על יחסים            |
| `\|`          | איחוד (Union)                                               | האופרטור `x \| y` מחשב את היחס (או ה-set) המורכב מכל הקישורים (או האירועים) ב-x או y או בשניהם. ביצוג מתמטי `∪`.                                                                                | חל על יחסים או קבוצות  |
| `(* *)`       | הערה                                                        | `(* This is a comment *)`                                                                                                                                                                       |                        |


### הצהרות נפוצות בקבצי Bell ו-Cat
הצהרות הנפוצות ביותר בקבצי Bell ו-Cat הן הצהרות הקצאה (`let` או `let rec`) והצהרות בדיקה.

- הצהרת `let`: משמשת להגדרת ערכים או יחסים חדשים.

- הצהרת `let rec`: נועדה להגדרות רקורסיביות, כולל הגדרות הדדיות בין מספר מבנים, והיא מורכבת יותר מהצהרת `let` רגילה. לפעמים נדרשות הגדרות רקורסיביות  כדי לייצג את התנהגות של מודלי זיכרון שונים (כמו ב-arm)

- הצהרת  `include`: הצהרה שמאפשרת לכלול קבצים אחרים בתוך הקוד.

#### הצהרות בדיקה ב-herd

הכלי herd מציע שלושה סוגים של הצהרות בדיקה, שכל אחת מוודאת תנאי על יחס:

- הצהרת `acyclic`: דורשת שהיחס המחושב לא יכיל מחזורים. כלומר, אי אפשר לחזור לאותו אירוע דרך סדרה של קשרים.

- הצהרת `irreflexive`: דורשת שהיחס המחושב לא יהיה רפלקסיבי כלומר לא יכיל קישורים מאירוע לעצמו, אסור שתיהיה חזרה ישירה לאותו אירוע.

- הצהרת `empty`: דורשת שהיחס המחושב יהיו ריק, כלומר לא יכיל אף זוג אירועים.

הצהרות אלו מספקות כלי לבדיקת נכונותם של יחסים ומבנים בקוד, והן חיוניות למימוש וניתוח מודלים מורכבים בזיכרון.

ניתן להעניק שמות לבדיקות באמצעות סיומת `as` ולאחריו השם של הבדיקה.




#### כשל בבדיקות ואזהרות ב-herd

כאשר בדיקה נכשלת ב-herd, המשמעות היא שמודל הזיכרון אוסר על ביצוע המועמד הנבדק; כלומר, המודל קובע שהביצוע הזה לא יכול להתרחש במציאות. ניתן גם לשלוט על הבדיקה על ידי הוספת הקידומת `~`, שמשמעה שלילה של הבדיקה.

בנוסף, אפשר לסמן בדיקה באמצעות מילת המפתח `flag`. כאשר בדיקה מסומנת כזו מצליחה, זה מעיד על כך שהביצוע נתקל בבעיה סמנטית כלשהי. אם זה קורה, herd מוסיף אזהרה לפלט כדי להתריע על כך.

הצהרת `check`: הצהרה לביצוע בדיקות על יחסים וקבוצות שהוגדרו.

### תכונות מתקדמות בשפת cat וב-herd

שפת cat תומכת במגוון תכונות מתקדמות, כמו set-ים ו-tuple-ים, התאמת דפוסים, פונקציות שניתן להגדיר על ידי המשתמש, וגם איטרציה ורקורסיה בסגנון OCaml (השפה שבה כתוב herd), אבל אני לא אדון כאן בתכונות האלה והמתעניינים יכולים לקרוא את התיעוד.

## תהליך עיבוד ובדיקה ב-herd

אם קובץ Bell קיים, הוא מעובד תחילה ואחריו מתחיל העיבוד של הקובץ Cat.

לאחר טעינת קבצי Bell ו-Cat, הכלי herd ממשיך לנתח את מבחן הלקמוס. מבחן זה עשוי לכלול פקודות מאקרו, כגון `smp_mb()`, שהן למעשה קיצורי דרך לפעולות בסיסיות (כמו מחסום זיכרון עם תג `mb`). הרחבת פקודות המאקרו למבנים הבסיסיים מתבצעת לפי מיפוי המוגדר בקובץ, כמו `linux.def`, שמצוין באמצעות פרמטר ב-cli `-macros` או בקובץ קונפיגורציה עם שורת `macros`.

לאחר מכן, herd מפרש את התוכנית על ידי בניית רשימה של אירועים (event-ים) עבור כל thread בתוכנית. בתוכניות שנכתבו בשפה עילית כמו C, התהליך כולל פירוק הצהרות וביטויים לרצף של פעולות בסיסיות (כגון קריאה, כתיבה, חישובים לוגיים/אריתמטיים על רגיסטרים, תנאים וכדומה). בתוכניות שנכתבו בשפת אסמבלי, ההוראות הבודדות בדרך כלל מתאימות ישירות לפעולות אלה. עם זאת, פעולות אטומיות מסוג rmw מיוצגות תמיד כשילוב של שתי פעולות נפרדות – קריאה וכתיבה – המקושרות דרך יחס ה-rmw המובנה.

### ארגון אירועים לכל thread

האירועים בתוכנית מאורגנים כרשימה עבור כל thread, לפי סדר התוכנית (program order). עם זאת, חשוב להבין שסדר התוכנית מתייחס לסדר שבו ההוראות מוצגות ליחידת הביצוע של המעבד, ולא בהכרח לסדר שבו הן מופיעות בקוד המקור או קוד האובייקט של התוכנית. ברוב המקרים, שני הסדרים זהים, אך הם שונים כאשר ישנם branch-ים. אם מתבצע branch קדימה (forward branch), חלק מההוראות עשויות לא להתבצע ולהישאר מחוץ לרשימת האירועים, ואילו branch אחורה (backward branch) עשוי לגרום להוראות מסוימות לחזור שוב לרשימה.

### יצירת רשימות אירועים ב-branch-ים מותנים
בשל העובדה שאין דרך לדעת מראש האם יילקח branch מותנה, כל branch כזה יוצר שתי רשימות אירועים עבור הכלי herd: אחת שבה ה-branch נלקח, והשנייה שבה לא נלקח. לכן, תוכנית המכילה שני branch-ים מותנים תוביל ליצירת ארבע רשימות, תוכנית עם שלושה branch-ים תיצור שמונה רשימות, וכן הלאה. סדר האירועים בתוך כל רשימה נקבע על ידי יחס ה-po. הכלי herd נדרש לבדוק כל רשימה כזו בנפרד, מאחר שכל רשימה מייצגת ביצוע אפשרי של התוכנית.

### טיפול בלולאות ו-branch-ים חוזרים
כאשר התוכנית מכילה לולאה, ייתכן ש-branch מותנה יילקח מספר בלתי מוגבל של פעמים, מה שיכול להוביל לגידול לא פרופורציונלי במספר הביצועים האפשריים. כדי למנוע זאת, יש מגבלה על מספר הפעמים ש-herd יאפשר ל-branch מסוים להופיע בביצוע. מגבלה זו מוגדרת באמצעות הפרמטר `-unroll` ב-cli, שבדרך כלל מוגדר ל-2 איטרציות לכל היותר. אם הביצוע דורש מספר גבוה יותר של איטרציות, הוא פשוט לא ייחשב.

### בחירת ערכי קריאה וכתיבה
לאחר יצירת המועמדים לביצוע (candidate executions), herd נדרש להחליט, עבור כל אירוע קריאה, מאיזה אירוע כתיבה מתקבל הערך שהקריאה מחזירה. כמו במקרים של branch-ים מותנים, גם כאן אין דרך לדעת מראש איזה ערך ייקרא, ולכן אם לתוכנית יש יותר מכתיבה אחת לאותו משתנה, herd צריך לבחון את כל השילובים האפשריים של יחס ה-rf. תהליך זה יכול להוביל לגידול אקספוננציאלי במספר הביצועים האפשריים שיש לבדוק, בדומה לגידול שנוצר עקב branch-ים מותנים.

### ניתוח זרימת נתונים בתהליך עיבוד מועמד לביצוע
כאשר herd מעבד מועמד לביצוע, הוא מבצע ניתוח זרימת נתונים שמטרתו לנתח את הערכים המחושבים והמאוחסנים במשתנים המקומיים עבור כל thread בתוכנית. ניתוח זה משמש במספר תפקידים:

- הכלי herd בודק כל branch מותנה, ומוודא שהמצב הלוגי שלו תואם לבחירת הביצוע: כלומר, ה-branch נלקח רק כאשר התנאים המתאימים התקיימו.
- הכלי herd מאמת את כתובת היעד של כל גישה עקיפה לזיכרון (כגון גישה דרך מצביע או גישה יחסית למעבד), ומוודא כי יחס ה-rf אכן מקשר בין כתיבה לקריאה המתבצעות לאותה כתובת יעד.
- הכלי herd מזהה וקובע אילו סוגי תלויות קיימות בין אירועים המייצגים גישה לזיכרון, כולל תלות בנתונים, תלות בכתובות ותלות בשליטה. תלויות אלה זמינות למודל באמצעות קשרי data, addr ו-ctrl.

## שימוש והרצה ב-herd


### מבחני litmus

#### cross

אם רוצים להריץ מבחני litmus על מכונות אחרות שבהן אין את ה-diy tools אז אפשר ליצר את המבחן עצמו במכונה עם ה-diy-tools ולאחר מכן להריץ את המבחן עצמו על מכונה אחרת.

בהתחלה יוצרים את המבחן עצמו:

```sh {linenos=inline}
litmus7 -o /tmp/my_test.tar -os mac SB-TEST.litmus
```
הערה:
	במקרה הזה מכונת היעד היא mac
	
ולאחר מכן במכונה המרוחקת לאחר שמעבירים אליה את ה-`my_test.tar` (שמכיל את הפלט מהשלב הקודם):

```sh {linenos=inline}
mkdir SB && cd SB
tar xf /tmp/my_test.tar

sh run.sh
### or ###
sh comp.sh
```

#### klitmus

הכלי `klitmus7` מיועד להפעלת בדיקות לקרנל והבדיקות רצות כמודולים קרנלים. המודול קרנלי ש-klitmus יוצר ניתן לטעון ולפרוק דינמית בתוך קרנל פעיל. לאחר טעינת המודולים, הם מופעלים באמצעות קריאה לפסאודו-קובץ `/proc/litmus`, שמספק ממשק לתקשורת עם המודולים.

בנוסף לכך, `klitmus7` פועל אך ורק במצב קימפול cross, כלומר הוא מתרגם את המבחנים לכמה קבצי C, ומספק גם Makefile וסקריפט הפעלה בשם `run.sh`. כך ניתן לפשט את תהליך ההכנה וההרצה של הבדיקות הנדרשות במערכת.

##### דוגמה להרצה:

בשלב הראשון יוצרים את המבחן עצמו עם `klitmus7`:

```sh {linenos=inline}
klitmus7 -o X.tar SB+onces.litmus
```

```sh {linenos=inline}
mkdir -p X && cd X && tar xmf ../X.tar
make
```

```sh {linenos=inline}
sudo sh run.sh
```

### קטע filter לעומת exists

ישנם מקרים שבהם קטע ה-filter פועל במהירות רבה יותר, במיוחד במקרים הנפוצים, שכן הכלי herd7 מסוגל להפסיק את הביצוע ברגע שביטוי ה-filter לא מצליח להתקיים. בניגוד לכך, קטע ה-exists מקבל את הערך שלו בסוף הבדיקה, מה שדורש מ-herd7 להשקיע זמן בבדיקה של ביצועים מזויפים, שבהם שני הקטעים הקריטיים פועלים במקביל.

בנוסף לכך, ישנם אנשים המעדיפים את ההפרדה בין שמספק השימוש בקטעים filter ו-exists.

### דגל speedcheck

כדי להאיץ את הביצועים של herd7, ניתן להשתמש באפשרות `-speedcheck true`. אפשרות זו מונעת מ-herd7 ליצור את כל מצבי הקצה האפשריים ומכוונת אותו להתמקד בשאלה האם ניתן לקיים את קטע ה-exists או לא.

חשוב לציין כי ניתוח מבחן הלקמוס הוא בעל מורכבות אקספוננציאלית, הן כאשר משתמשים באפשרות `-speedcheck true` והן כאשר לא. אם אינכם מעוניינים בשימוש בארגומנטים של cli, ניתן להשיג מהירות דומה על ידי הוספת משפט filter עם אותו ביטוי בדיוק כמו קטע ה-exists.





### הצגת תוצאת `exists`

כשרוצים לראות את התוצאה של הפסקת `exists` אפשר להוסיף את הדגל `show` עם `prop`:
```sh {linenos=inline}
-show prop
```

### הצגה של קשרים

אפשר להציג קשרים ב-2 דרכים, או דרך המודל עצמו או להעביר דגל בהרצת herd7.

#### דרך המודל

צריך פשוט לכתוב את המילת מפתח `show` ואחריה את הקשרים שרוצים להציג מופרדים בפסיקים בקובץ cat.

לדוגמה:
```ocaml {linenos=inline}
show ppo,cumul-fence
```

הערה:
	לפעמים herd7 לא מראה ביצוא תמונה את הקשרים בין אירועים גם אם יש כאלו ובפעמים כאלו כדי "ללחוץ" עליו לעשות את זה אפשר לכוון אותו יותר ספציפי כמו למשל על ידי `& ext` או `& int` לדוגמה.

#### דרך ה-cli

אפשר להשתמש בדגל `doshow`.

לדוגמה:

```sh {linenos=inline}
-doshow pb
```

אפשר גם להשתמש הפוך ולא להציג קשרים עם הדגל `unshow` באותה צורת שימוש.

```sh {linenos=inline}
-unshow rf,co
```


### הצגת תוצאות אסורות
כשרוצים לראות תוצאה אסורה יש קצת בעיה בהרצה רגילה כי היא אסורה ולכן גם אם משתמשים ב-`show` הפלט יהיה קובץ ריק, אבל אם בכל זאת רוצים לראות את התוצאה האסורה (למשל כדי לראות את המעגליות) אז יש מספר דגלים שיכולים לעזור:

#### הדגל `through`

הדגל אומר ל-herd תן לריצות נוספות להגיע לשלב הסופי של מנוע herd7, אפשרות זו מאפשרת למשתמשים ליצור תמונות של הרצות אסורות, אשר נדחות אחרת בשלב מוקדם של מנוע herd7.

כלומר, ברירת המחדל `none` מאפשר רק ביצועים תקפים (לפי המודל הפעיל) לעבור. ההתנהגות של אפשרות זו שונה בין דגמי קבצי טקסט פנימיים וטקסט:

הערה:
	הכוונה במודלים פנימיים (internal) הם מודלים של herd7 עצמו (כמו `cav12`, `minimal` ו-`uniproc`) ולעומת זאת מודלי טקסט הם מודלים שהמתמש יכול לבחור להעביר.

- עבור מודלים פנימיים: כל התג מאפשר לכל הרצות לעבור; בעוד שהתג `invalid` ידחה ביצועים שמפרים את `uniproc`, תוך מתן אפשרות לביצוע אסור אחר לעבור.

- מודלים של קבצי טקסט: התגים `all` ו-`invalid` מאפשרים לכל הביצועים לעבור. עבור מודלים כאלה, ניתן להשיג שליטה מדויקת יותר על הרצות שמגיעות לשלב הסופי של herd7 עם האפשרות`skipcheck`.

ברירת המחדל היא `none`.


בקיצור אפשר להוסיף את הדגל:

```sh {linenos=inline}
-through invalid
```


#### הדגל `skipchecks`

אפשרות זו חלה על מודלי קבצי טקסט. הוא מורה ל-herd7 להתעלם מתוצאות הבדיקות שניתנו. 

ואפשר להעביר את השמות ברצף עם הפרדה של פסיקים (`,`) בין השמות.

לדוגמה אפשר להוסיף את הדגל:
```sh {linenos=inline}
-skipchecks coherence,happens-before,propagation
```


##### בדיקות בקובץ המודל
על מנת שהאפשרות תפעל, יש לתת שמות של הבדיקות בקובץ המודל עם מבנה:

```ocaml {linenos=inline}
as <NAME>
```

למשל דוגמה מהמודל של הקרנל בקובץ `linux-kernel.cat`:

```ocaml {linenos=inline}
acyclic hb as happens-before
```

#### שילוב של הדברים ביחד

כשרוצים לראות למה תוצאה אסורה אפשר להשתמש בדגלים בצורה הבאה:

```sh {linenos=inline}
 -through invalid -show prop -o <DIR>
```

לדוגמה:

```sh {linenos=inline}
herd7 -through invalid -bell linux-kernel.bell -macros linux-kernel.def -cat linux-kernel.cat my_tests/C-Z6.0+o-mb-o+acq-o+o-mb-o.litmus -show prop -o ~/kernel/out
```

ולאחר מכן אפשר להפוך את הפלט של herd7 לתמונה בפורמט png עם הבינארי `dot` (בלינוקס) שמגיע בחבילה `graphviz`.


[לקריאה נוספת על הדגלים אפשר לבדוק בתיעוד באתר של herd](https://diy.inria.fr/doc/herd.html)


### פרמטרים נוספים ב-CLI:

- `-o <dest>`:
	שומר את קוד C של קבצי הבדיקה בכתובת `<dest>` במקום להריץ אותם.
	אם `<dest>` הוא ארכיון (סיומת `.tar`) או ארכיון דחוס (סיומת `.tgz`), הכלי litmus7 יבנה ארכיון (וזה בעצם תכונת קימפול cross), ואחרת `<dest>` יתפרס כשם של תיקייה קיימת שבה נשמרות הבדיקות.

- `-crossrun <(user@)?host(:port)?|adb|qemu(:exec)?>`:
	כאשר נעשה שימוש בדרייבר של ה-shell (שזה ברירת המחדל של האפשרות driver), שני הארגומנטים הראשונים מאפשרים לסקריפט `run.sh` להריץ בדיקות בודדות במחשב מרוחק.
	
- אפשרות SSH:
	- הפרמטר `user` הוא שם המשתמש להתחברות במחשב המרוחק.
	- הפרמטר `<host>` הוא שם המחשב המרוחק.
	- לא חובה להוסיף את מספר ה-port ברירת מחדל (22).

- אפשרות QEMU:
	- הבדיקות יופעלו עם הסימולטור QEMU, כאשר ניתן לציין את שם הבינארי (executable) שלו לאחר `:`. ברירת המחדל היא ששם ההפעלה הוא `qemu`.
	- הארגומנט `qemu` מורה לסקריפט ה-shell להשתמש באמולטור QEMU. יש להגדיר את משתנה הסביבה QEMU לנתיב של האמולטור לפני הפעלת הסקריפט `run.sh`, לדוגמה: `QEMU=qemu sh run.sh` (שימוש בתחביר של sh).





## docker herdtools7

### Dockerfile
קובץ Dockerfile לדוגמה להרצת כלי herdtools7:

```sh {linenos=inline}
FROM ocaml/opam

WORKDIR /home/opam

RUN opam install herdtools7
USER root

RUN apt update
RUN apt install -qq -y openssh-server

RUN echo "root:Password1" | chpasswd
RUN echo "opam:Password1" | chpasswd
RUN sed -i "s/#PermitRootLogin prohibit-password/PermitRootLogin yes/g" /etc/ssh/sshd_config
RUN service ssh start
RUN echo "check-certificate=off" > /root/.wgetrc

RUN mkdir -p /home/opam/kernel

# USER opam
# RUN ssh-keygen -A

EXPOSE 22
CMD ["/usr/sbin/sshd", "-D"]
```


### בניית ה-container
```sh {linenos=inline}
# docker pull ocaml/opam # ???
docker build . -t herd
docker run -p 2231:22 -v <KERNEL_PATH>:"/home/opam/kernel" herd

ssh opam@127.0.0.1 -p 2231
```

### שימוש ב-container

```sh {linenos=inline}
docker start 9a7f3dd8da6c

ssh opam@127.0.0.1 -p 2231 # Password1
### or ###
docker exec -it 9a7f3dd8da6c bash

cd kernel/tools/memory-model

herd7 -macros linux-kernel.def -bell linux-kernel.bell -cat linux-kernel.cat t1/test02.litmus -show prop -o ~/kernel/out
```
### יצוא דיאגרמה

```sh {linenos=inline}
sudo apt update -y
sudo apt install -y graphviz

herd7 <CMD> -show all -o <DIR>

dot -Tpng <FILE.dot> > <OUTPUT>.png
```




---



