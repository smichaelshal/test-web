+++
Sources = [
"https://github.com/torvalds/linux/blob/master/tools/memory-model/Documentation/explanation.txt",
"https://github.com/paulmckrcu/oota",
"https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/pldi105-sarkar.pdf",
"https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/StrongModel.html",
"https://github.com/paulmckrcu/perfbook",
"https://www.kernel.org/doc/Documentation/memory-barriers.txt",
"https://developer.arm.com/documentation/102336/0100/Different-Observers",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-11"
categories = [

]
series = [

]
title = "Dependency"
+++

## מבוא

תלות בין פעולות זיכרון קיימת כשביצוע פעולה אחת תלוי בתוצאת פעולה אחרת. תלות זו מתרחשת כאשר פעולה ראשונה (קריאה) מספקת ערך שמשפיע על התנהגות הפעולה השנייה (קריאה או כתיבה).

כאשר קיימת פעולה של כתיבה שיש לה תלות סמנטית בקבוצה מסוימת של פעולות קריאה, חשוב שהכתיבה תתבצע רק לאחר שכל פעולות הקריאה הללו הושלמו. השלמת הקריאה מוגדרת כאן לפי פרספקטיבה של זמן גלובלי, כלומר, כתיבה תלויה לא יכולה להופיע כאילו בוצעה לפני סיום פעולת הקריאה האחרונה שעליה היא תלויה. משמעות הדבר היא שמודל הזיכרון חייב להבטיח שכתיבה כזו תשמור על סדר עקבי ביחס לקריאות שהשפיעו על ערכה.

בזרימת המידע **בתוך המעבד** ניתן להגדיר תלות בין שתי הוראות I ו-J כך: הוראה J תלויה בהוראה I אם אחד מפלטי I משמש כקלט עבור J. תלות זו יכולה להיות ישירה או עקיפה (באמצעות סדרת הוראות ביניים).

אם שינוי בפלט של הוראה I גורם לשינוי בפעולה או בתוצאה של הוראה J, המשמעות היא שהוראה I חייבת להתחייב לפני הוראה J. כתוצאה מכך, גם בארכיטקטורות שמאפשרות ביצוע מחוץ לסדר, תלות יכולה לכפות סדר התחייבות מסוים.

### תלות תחבירית מול סמנטית

תלות נחשבת תחבירית בלבד כאשר הגישה השנייה בקוד נראית כאילו היא תלויה בראשונה, אך בפועל אינה מושפעת מתוצאתה. לדוגמה:

```c {linenos=inline}
r1 = READ_ONCE(x);
WRITE_ONCE(y, r1 * 0);
```

במקרה זה, נראה כי הכתיבה ל-`y` תלויה בקריאה מ-`x`, אך מאחר שהתוצאה תמיד תהיה אפס (עקב הכפלה ב-0), אין בפועל תלות סמנטית בין שתי הגישות.

במקרים מסוימים, ניתן לנצל תלויות שמתקיימות באופן טבעי באלגוריתם, אך לפעמים כדאי להוסיף תלות באופן מלאכותי כדי לשלוט על תכונות הסדר, כמו לדוגמה שימוש ב-XOR כדי ליצור ערך עם עצמו ולהוסיף אותו לחישוב הכתובת.
### השפעת הקומפיילר

במצבים שבהם התלות היא תחבירית בלבד, הקומפיילר עשוי להסיר או לשנות את סדר הגישות, משום שאינו מזהה תלות אמתית בין הפעולות.

## סוגי תלות

קיימים מספר יחסים שמגדירים סוגים שונים של תלות בין פעולות זיכרון המתבצעות באותו thread:
### תלות כתובת

מתאר מצב שבו הערך שנטען על ידי פעולה קודמת משמש לבניית הכתובת של פעולה עוקבת (load או store). לדוגמה, אם תוכן של כתובת מסוימת נקרא והערך הזה משמש כדי לקבוע את הכתובת לפעולה הבאה, נוצר קשר תלות כתובת.

#### דוגמה:

```c {linenos=inline}
int a[20];
int i;

r1 = READ_ONCE(i);
r2 = READ_ONCE(a[r1]);
```


כאן, הקריאה מ-`a[r1]` תלויה בערך של `r1`, שנקרא מ-`i`. במילים אחרות, המיקום שאליו הגישה מתבצעת (אינדקס המערך `r1`) תלוי בערך שהקריאה הראשונה מספקת.

### תלות data

תלות זו מתרחשת כאשר ערך שנקרא על ידי קריאה משפיע ישירות על הערך שנשמר בזיכרון על ידי כתיבה. 

#### לדוגמה:

```c {linenos=inline}
int x, y;

r1 = READ_ONCE(x);
WRITE_ONCE(y, r1 + 5);
```


בדוגמה זו, הערך של `r1` שנקרא מ-`x` משפיע ישירות על הערך שנכתב ל-`y`. תלות data יכולה להיות פשוטה או לעבור דרך חישובים מורכבים, ובמקרים מסוימים, כתיבה יכולה להיות תלויה בתוצאות של מספר קריאות שונות.
### הבחנה בין תלות data לתלות כתובת

במקרים שבהם הערך המוחזר מ-load שמשמש לחישוב הכתובת שבה ה-store מאוחר יותר יבצע כתיבה, מדובר בתלות כתובת ולא בתלות נתונים. כלומר, תלות data מתמקדת בתוכן, בעוד שתלות כתובת עוסקת במיקום הזיכרון.
### תלות בקרה

תלות בקרה מתרחשת כאשר הערך המוחזר מהוראת load משפיע על החלטה האם הוראת store מאוחרת יותר תתבצע או לא.

חשוב להדגיש כי תלות בקרה מספקת סדר אך ורק בין הוראות load להוראות store.

ביצוע branch מותנה (conditional branch) או הוראת mov מותנית, עשוי לתפקד כמעין מחסום זיכרון בעל תקורה נמוכה. הסיבה לכך היא שהמעבד חייב להבטיח את הסדר הנכון בין פעולות ה-load וה-store כדי לוודא שהתנאי מתבצע כהלכה.
#### דוגמה:

```c {linenos=inline}
int x, y;
r1 = READ_ONCE(x);
if (r1)
	WRITE_ONCE(y, 1984);
```

בדוגמה זו:

1. הקריאה מ-`x` מתבצעת והערך מאוחסן ב-`r1`.
2. הערך של `r1` משפיע על הערכת התנאי `if (r1)`.
3. כתוצאה מהערכת התנאי, ייתכן שהכתיבה ל-`y` תתבצע (או לא), תלוי בתוצאת הקריאה.

בכך נוצר קשר בין הקריאה לכתיבה, כאשר תנאי הכתיבה תלוי באופן ישיר בערך שנקרא קודם לכן.

תלות זו נובעת מהקשר התחבירי של פעולות הקריאה והכתיבה בקוד, כאשר הכתיבה נמצאת תחת משפטי `if` או `switch` שתלויים בערך של קריאה קודמת.

תלות בקרה רלוונטית רק לקוד שנמצא בתוך הבלוקים then או else של תנאי `if`. היא אינה משפיעה ישירות על קוד שנמצא לאחר הבלוק של ה-`if`.

#### בעיה בתלות בקרה

בקטע הקוד הבא:

```c {linenos=inline}
q = READ_ONCE(a);
<implicit address-dependency barrier>
if (q) {
	/* BUG: No address dependency!!! */
	p = READ_ONCE(b);
}
```

הקריאה מ-`b` תלויה בבדיקה של `q`, שהיא תוצאה של הקריאה מ-`a`.

הבעיה: אין כאן תלות כתובת ישירה בין הפעולות, אלא תלות בקרה. המעבד עשוי לנסות לחזות מראש את תוצאת התנאי `if (q)` ולבצע את הקריאה מ-`b` לפני הקריאה מ-`a`, כך שמעבדים אחרים יראו את הקריאה מ-`b` מתרחשת מוקדם מדי.

כדי למנוע את הבעיה, יש להוסיף מחסום קריאה מפורש בקוד:

```c {linenos=inline}
q = READ_ONCE(a);
if (q) {
	<read barrier>
	p = READ_ONCE(b);
}
```

מחסום זה מבטיח שמחויבות לקריאה מ-`a` תושלם לפני ביצוע הקריאה מ-`b`.
#### תלות בקרה וקומפיילרים

קומפיילרים אינם מודעים לתלות בקרה באופן אינהרנטי, ולכן התפקיד שלך לוודא שהקומפיילר לא ישבור את הסדר המיועד. יש להקפיד על שימוש נכון ב-macro-ים כמו `READ_ONCE()` ו-`WRITE_ONCE()` של הקרנל כדי למנוע אופטימיזציות לא רצויות שעלולות לשנות את סדר הפעולות.

## LKMM

### תלות בקרה ומחסומי זיכרון ב-LKMM

ב-LKMM תלות בקרה יכולה להבטיח סידור בין קריאות זיכרון קודמות לבין כתיבות מאוחרות יותר, אך היא לא מבטיחה סדר בין קריאות קודמות לקיראות מאוחרות יותר, וגם לא בין stores קודמות לכל דבר מאוחר יותר. כדי להשיג סידור בין loads או בין stores, יש להשתמש במחסומי זיכרון נוספים.

תלות בקרה בדרך כלל משתלבת עם סוגים אחרים של מחסומים, משום שהיא אינה מבטיחה את כל הסדרים הנדרשים. אם אתה זקוק לאטומיות מוחלטת או לסידור מלא של פעולות, יש לשלב את תלות הבקרה עם מחסומים נוספים.

תלות בקרה אינה מבטיחה אטומיות מרובת עותקים. אם יש צורך שכל המעבדים יראו כתיבה מסוימת בו-זמנית, יש להשתמש ב-`smp_mb` כדי להבטיח שמירה על האטומיות.

מחסום כתיבה משתלב עם מחסום תלות כתובת, תלות בקרה. באופן דומה מחסום קריאה, תלות בקרה או מחסום תלות כתובת משתלבים עם מחסום כתיבה, מחסום acquire, מחסום release או מחסום כללי.
### יחסים

- קשר ctrl המובנה:
	קשר זה מקשר גישת קריאה לכל גישה לזיכרון בהוראת branch מותנית, כאשר ההחלטה על הביצוע תלויה בערך הקריאה.

	מודל הזיכרון מחשב את הביטוי `ctrl & (R*W)` כדי להגביל את המטרות של תלות בקרה אלה לגישות כתיבה בלבד.

- קשר addr המובנה וקשר data:
	קשרים אלו מקשרים גישת קריאה לכל גישה מאוחרת יותר שנעשית עם כתובת או תלות נתונים מהקריאה.

- הקשר dep:
	הקשר מוגדר כאיחוד של קשר data ו-addr, כלומר הוא מתאר את התלות בין גישות הקריאה והכתיבה שמתרחשות על בסיס כתובת או נתונים.

- הקשר dep-rfi:
	מודל הזיכרון מגדיר קשר זה כתהליך של חיבור (concatenation) בין הקשר dep לקשר rfi. ה-rfi מקשר בין כתיבה לקריאה באותו thread שמבצע את הקריאה והכתיבה. קריאות אלו עשויות להיות מסופקות (satisfied) על ידי העברת הכתיבה או על ידי מעבר דרך תת-מערכת הזיכרון, אך בכל מקרה, ההשפעה היא זהה: הקריאה שבסוף הקישור של ה-rfi חייבת להתבצע לאחר הקריאה שבתחילת הקישור של ה-dep.

- הקשר addrpo:
	קשר זה מוגדר כחיבור של קישור addr עם קישור po. מודל הזיכרון מחשב את הביטוי`addrpo & (R*W)`, ובכך מחבר קריאות שמבוססות על תלות בכתובת עם כתיבות שנמצאות בסדר שנשמר (ב-po) ביחס ליעד התלות.
#### יחס סדר PPO

כל הארכיטקטורות הנתמכות בלינוקס אכן מבצעות loads לפי סדר התוכנית כאשר יש ביניהם תלות כתובת. אחרי הכל, המעבד לא יכול לבקש מתת-מערכת הזיכרון לטעון ערך ממיקום מסוים לפני שהוא יודע מהו המיקום הזה.

עם זאת, תלות יכולה להשפיע בעקיפין על סדר הביצוע של שני loads. מצב כזה מתרחש כאשר יש תלות מ-load ל-store ו-load שני מאוחר יותר קורא מאותה store. הדוגמה לכך היא:
`R -> dep W -> rfi R'`

כאשר קישור התלות (dep) יכול להיות תלות כתובת או תלות בנתונים. במצב זה, יש אפשרות שהמעבד יבצע את `R'` לפני `W`, שכן הוא יכול להעביר את הערך ש-`W` יאחסן ל-`R'`. אך הוא לא יכול לבצע את `R'` לפני `R`, כי הוא לא יכול להעביר את הערך לפני שהוא יודע מהו הערך הזה, או ש-`W` ו-`R'` ניגשים לאותו מיקום בזיכרון.

אם התלות בין `R` ל-`W` היא רק תלות בקרה, המעבד יכול לבצע את `W` באופן ספקולטיבי ולבצע אותו לפני `R'`, כל עוד הוא לא יודע אם ביצוע זה נכון. אם הספקולציה מתבררת כשגויה, המעבד רק יצטרך להפעיל מחדש או לנטוש את `R'`.

בתאוריה מעבד עשוי להעביר store ל-load כאשר יש תלות כתובת, כמו בדוגמה הבאה:

```c {linenos=inline}
r1 = READ_ONCE(ptr);
WRITE_ONCE(*r1, 17);
r2 = READ_ONCE(*r1);
```

הסיבה לכך היא שהמעבד יכול לדעת מראש שה-store וה-load השני ניגשים לאותו מיקום בזיכרון, עוד לפני שהוא יודע מהי כתובת המיקום. עם זאת, אף אחת מהארכיטקטורות הנתמכות על ידי הקרנל של לינוקס לא מבצעת אופטימיזציה כזו.
#### refcounters

תלות בקרה (במקרה של הצלחה) עבור refcounters מבטיחה שאם הפניה לאובייקט הושגה בהצלחה (כלומר, אם התרחשה הגדלה או הוספה של המונה וחזר ערך true), אז פעולות store נוספות מסודרות לאחר פעולה זו. כלומר, stores נוספים לא יבוצעו לפני שההגדלה של המונה הושלמה בהצלחה. תלות זו לא מיושמת באמצעות מחסומים מפורשים, אלא היא מבוססת על כך שהמעבד לא יבצע ספקולציות על פעולות store. מדובר ביחס שמתקיים רק בתוך המעבד עצמו ואינו מספק ערבויות למעבדים אחרים במערכת.

## AArch64

ארכיטקטורת AArch64 אינה דורשת סדר ספציפי בין גישות שמתבצעות על ידי observer-ים שונים, גם כאשר קיימת תלות בכתובות. לדוגמה, הקוד הבא יכול להתבצע ולהשלים בכל סדר, למרות שמצויה תלות בין הגישות:

```asm {linenos=inline}
DC CVAU, X0 ; Operations are executed in any order
IC IVAU, X0 ; despite address dependency.
```

אם ההוראות מבוצעות מחוץ לסדר, ייתכן כי instruction cache יתמלא בנתונים מיושנים מה-data cache. כדי למנוע בעיה זו, הארכיטקטורה דורשת שימוש במחסום זיכרון. 

דוגמה לכך ניתן לראות בקוד הבא:

```asm {linenos=inline}
DC CVAU, X0 ; Operations are executed in any order
DSB ISH
IC IVAU, X0 ; despite address dependency.
```

במקרה זה, ה-`DC CVAU` (ניקוי ה-data cache) חייב להתבצע ולהשלים לפני ביצוע ביטול instruction cache (הוראת `IC IVAU`). ה-`DC CVAU` מבטיח כי הנתונים החדשים יהיו זמינים ל-cache ההוראות לפני ביצוע הביטול.

