+++
Sources = [
"https://en.wikipedia.org/wiki/Memory_barrier",
"https://www.kernel.org/doc/Documentation/memory-barriers.txt",
"https://preshing.com/20120710/memory-barriers-are-like-source-control-operations/",
"https://preshing.com/20120515/memory-reordering-caught-in-the-act/",
"https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf",
"https://pages.cs.wisc.edu/~markhill/papers/primer2020_2nd_edition.pdf",
"https://www.ibm.com/docs/en/openxl-c-and-cpp-aix/17.1.0?topic=sf-lwsync-builtin-ppc-lwsync-iospace-lwsync-builtin-ppc-iospace-lwsync",
"https://www.ibm.com/docs/en/openxl-c-and-cpp-aix/17.1.0?topic=sf-sync-builtin-ppc-sync-iospace-sync-builtin-ppc-iospace-sync",
"https://documentation-service.arm.com/static/65fdad3c1bc22b03bca90781?token=",
"https://developer.arm.com/documentation/100941/0101/Barriers",
"https://mariokartwii.com/armv8",
"https://developer.arm.com/documentation/102336/0100/Instruction-barriers",
"https://developer.arm.com/documentation/102336/0100/Memory-barriers",
"https://developer.arm.com/documentation/102336/0100/Data-Synchronization-Barrier",
"https://developer.arm.com/documentation/102336/0100/When-is-an-access-considered-complete-",
"https://developer.arm.com/documentation/102336/0100/Different-Observers",
"https://developer.arm.com/documentation/102336/0100/Limiting-the-scope-of-memory-barriers",
"https://developer.arm.com/documentation/ka002179/latest/",
"https://diy.inria.fr/herd/herding-cats-color.pdf",
"https://inria.hal.science/hal-01081364/document",
"http://www.rdrop.com/users/paulmck/scalability/paper/N2745r.2009.02.27a.html",
"https://acg.cis.upenn.edu/papers/cav12_axiomatic_power.pdf",
"https://cseweb.ucsd.edu/classes/sp06/cse240b/manuals/power4-2.pdf",
"https://www.cl.cam.ac.uk/~pes20/cppppc-supplemental/pldi010-sarkar.pdf",
"https://www.cl.cam.ac.uk/~pes20/armv8-mca/armv8-mca-draft.pdf",
"https://developer.arm.com/documentation/genc007826/latest",
"http://www0.cs.ucl.ac.uk/staff/j.alglave/papers/toplas21.pdf",
"https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/pldi105-sarkar.pdf",
"https://github.com/torvalds/linux/blob/master/tools/memory-model/Documentation/explanation.txt",
"https://github.com/torvalds/linux/blob/v5.10/Documentation/core-api/atomic_ops.rst",
"https://github.com/torvalds/linux/blob/master/tools/memory-model/Documentation/recipes.txt",
"https://lwn.net/Articles/576486/",
"https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/WeakModel.html",
"https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/StrongModel.html",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-11"
categories = [

]
series = [

]
title = "mb"
+++




- [x] לבדוק את הקטעים בעמוד [Barrier - זמני](https://smichaelshal.github.io)




- [ ] להוסיף דוגמאות והסברים למחבני לקמוס ומודל של הצטברות ב-PPC ו-ARMv7
- [ ] לבדוק על איזה גרסאות PPC אני מדבר במאמר
- [ ] לבדוק אם אני כותב על מה קורה לסידור זיכרון במקרה שפעולת rmw עם תנאי שנכשלת.



- [x] לבדוק את הדוגמה [6.4 Causal consistency issues with Multiple observers במאמר של ARMv7 ](file:///Users/michael/Desktop/1/תכנות/kernel/files/Barrier_Litmus_Tests_and_Cookbook_A08%20(2).pdf#page=12)

- [x] לעשות את המבחני לקמוס של הצטברות [במאמר Understanding POWER Multiprocessors](https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/pldi105-sarkar.pdf)

- [x] לקרוא את החלקים על הצטברות [במאמר Herding Cats: Modelling, Simulation, Testing, and Data Mining for Weak Memory](https://inria.hal.science/hal-01081364/document)

- [x] לחזור על המודל האופרטיבי  [במאמר Understanding POWER Multiprocessors](https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/pldi105-sarkar.pdf)

- [x] לעשות את המבחני לקמוס של הצטברות [במאמר של הקרנל](https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/StrongModel.html) (להמשיך ממבחן 5 כולל אותו צריך לעשות)

## מבוא

מחסום זיכרון הוא הוראה המיועדת לאכוף מגבלות סדר על פעולות זיכרון המבוצעות לפני ואחרי הוראת המחסום. זה מתבטא בכך שפעולות זיכרון שביצוען סודר לפני המחסום יבוצעו לפני כל פעולות זיכרון שניתן להן לאחר המחסום.

חשיבות האכיפה שהמחסומים מספקים נובעת מהעובדה שמעבדים והתקנים אחרים במערכת עשויים לנצל מגוון טכניקות לשיפור ביצועים, כמו שינוי סדר ההוראות, דחייה ושילוב של פעולות זיכרון, ביצוע loads ספקולטיביות, חיזוי ספקולטיבי של branch-ים ושימוש בסוגים שונים של cache. מחסומי זיכרון נועדו לעקוף או לדכא את הטכניקות הללו או את השפעותיהם, כך שהקוד יכול לשלוט בצורה צפויה באינטראקציות בין מספר מעבדים או בין מעבד למכשירים.

הסידור מחדש המודבר כאן בדרך כלל אינו משפיע על ביצוע בתוך thread בודד, אך הוא עלול לגרום להתנהגות בלתי צפויה כאשר מספר thread-ים פועלים בו זמנית, אלא אם כן סדר הביצוע נשלט בקפידה. אופי האילוצים שהמחסום מטיל תלוי בחומרה ובמודל סדר הזיכרון של הארכיטקטורה הספציפית. כמה ארכיטקטורות מספקות סוגים שונים של מחסומים לאכיפת אילוצי סדר מגוונים.

 מחסומי זיכרון נחוצים רק כאשר יש סיכון לאינטראקציה בין שני מעבדים או בין מעבד למכשיר. אם ניתן להבטיח שלא תהיה אינטראקציה כזו בחלק מסוים של הקוד, אז אין צורך בשימוש במחסומי זיכרון בחלק זה. 

בדרך כלל, מחסומי זיכרון משמשים ביישומים של קוד low-level שרץ קרוב יחסית לחומרה, במיוחד כאשר הקוד פועל על זיכרון המשותף למספר מכשירים. דוגמאות לקוד כזה כוללות פרימיטיבי סנכרון, מבני נתונים lockless במערכות מרובות מעבדים, ודרייברים שעוברים אינטראקציה עם חומרת מחשב.

כאשר תוכנה פועלת על מערכת בעלת מעבד יחיד, החומרה דואגת לניהול הסדר הנדרש כדי להבטיח שהתוכנית תתבצע כאילו כל פעולות הזיכרון נעשו בסדר המוגדר על ידי המתכנת, כלומר בסדר התוכנית. במקרים אלו, אין צורך בשימוש במחסומי זיכרון. עם זאת, כאשר הזיכרון משותף עם התקנים מרובים, כמו מעבדים אחרים במערכת מרובת מעבדים או ציוד היקפי שממופה לזיכרון, עלולות להתרחש בעיות בגישה לא-מעודכנת, דבר שיכול להשפיע על התנהגות התוכנית. לדוגמה, ייתכן שמעבד שני יזהה שינויים בזיכרון שביצע המעבד הראשון בסדר שונה מזה של סדר התוכנית.

המצב הזה רלוונטי כאשר מדובר בשני thread-ים או יותר הפועלים על שטח זיכרון משותף שבו מספר thread-ים.

שם נפוץ למחסום זיכרון הוא גדר (fence) זיכרון ואולי זה באמת יותר מתאים בגלל שהוראות מחסום לא משפיעות על סדר פעולות הזיכרון בליבות אחרות. 

### מחסומי זיכרון וההשפעות של סידור מחדש

הוראות מחסום זיכרון מתייחסות להשפעות של סידור מחדש רק ברמת החומרה. יש לזכור כי קומפיילרים עשויים לסדר מחדש הוראות כחלק מתהליך האופטימיזציה של התוכנית. אמנם ההשפעות על התנהגות של תוכנה מקבילה יכולות להיות דומות בשני המקרים, בדרך כלל יש צורך לנקוט באמצעים נפרדים כדי למנוע אופטימיזציות של סדר מחדש על ידי הקומפיילר עבור נתונים שעשויים להיות משותפים על ידי מספר thread-ים שמבצעים.

### סוגים של מחסומי זיכרון

בחלק מהארכיטקטורות קיימות מספר הוראות מחסום, וכל אחת מהן מציעה מאפייני סידור שונים, אבל אפשר לרוב לחלק את המחסומים למספר קבוצות:

- **מחסומי זיכרון כתיבה (store barriers)**:
	
	מחסום זיכרון כתיבה (נקרא גם מחסום store או store-store) מספק ערובה לכך שכל פעולות הכתיבה המצוינות לפני המחסום ייראו כמתרחשות לפני כל פעולות הכתיבה שצוינו לאחר המחסום, ביחס לשאר רכיבי המערכת. מחסום כתיבה יוצר סדר חלקי שחל רק על פעולות הכתיבה, והוא לא מחייב השפעה על פעולות הקריאה (load).
	
	ניתן לראות במעבד כמבצע רצף של פעולות store למערכת הזיכרון ככל שהזמן מתקדם. כל ה-stores **לפני** מחסום כתיבה יתרחש **לפני** כל ה-stores לאחר מחסום הכתיבה.

	חשוב לציין שבדרך כלל יש לשלב מחסומי כתיבה עם מחסומי קריאה או עם תלות בכתובת.

- **מחסומי זיכרון קריאה (load barriers)**:
	
	מחסום קריאה (נקרא גם מחסום load או load-load) מספק ערובה לכך שכל פעולות הקריאה (load) שצוינו לפני המחסום ייראו כמתרחשות לפני כל פעולות הקריאה שצוינו לאחר המחסום, ביחס לשאר רכיבי המערכת. מחסום קריאה יוצר סדר חלקי שמחייב רק את פעולות הקריאה, והוא לא משפיע בהכרח על פעולות הכתיבה.
	
	מחסומי זיכרון קריאה יכולים להצביע על מחסומי תלות כתובת, ולכן ניתן להחליפם. בנוסף, יש לשים לב שברוב המקרים יש להתאים מחסומי קריאה עם מחסומי כתיבה.

	מחסום קריאה לא מבטיח תמיד למשוך את הגרסה האחרונה והמעודכנת ביותר. ייתכן שהוא יקבל גרסה ישנה יותר, כל עוד הגרסה הזו היא לפחות חדשה כמו הערך האחרון שהגיע למעבד שמבצע את המחסום. למרות שזה נשמע כמו הבטחה חלשה, בפועל זה מספיק כדי למנוע מצב שבו רואים נתונים מיושנים.
	

- **מחסומי זיכרון כלליים**:
	
	מחסום זיכרון כללי מספק ערובה לכך שכל פעולות ה-load וה-store המצוינות לפני המחסום ייחשבו כמתרחשות לפני כל פעולות ה-load וה-store שצוינו לאחר המחסום, בהקשר לשאר רכיבי המערכת. מחסום זיכרון כללי יוצר סדר חלקי שכולל הן את פעולות הקריאה והן את פעולות הכתיבה.
	
	מחסומי זיכרון כלליים מצביעים על מחסומי זיכרון קריאה וכתיבה, ולכן ניתן להחליף את אחד מהם.

	המחסום מספק הבטחה לגבי load לפני המחסום ו-store אחרי המחסום ולכן הוא נחשב גם מחסום store-load, וזה מבטיח שכל פעולות stores שבוצעו לפני המחסום יהיו גלויים לשאר המעבדים, ושכל פעולות loads שלאחר המחסום יקבלו את הערך העדכני ביותר שהיה בזמן ביצוע המחסום. כלומר, מחסום זה מונע את סידור מחדש של כל פעולות הכתיבה שהתרחשו לפניו עם פעולות הקריאה שאחריו, ובכך משמר את הסדר הנכון של ביצוע הפעולות במערכות מרובות מעבדים.
	
	במרבית המעבדים, הוראות שפועלות כמחסום store-load נוטות להיות יקרות יותר מבחינת ביצועים בהשוואה למחסומים האחרים.
### מה אי אפשר להניח לגבי מחסומי זיכרון?

ישנם כמה דברים חשובים שיש להבין לגבי מחסומי הזיכרון בקרנל, אשר אינם מובטחים:

- **שלמות הגישה לזיכרון**: אין ערובה לכך שכל גישה לזיכרון שהתרחשה לפני מחסום זיכרון תושלם במלואה לאחר ביצוע הוראת המחסום. כלומר, מחסום הזיכרון יכול להיחשב כמתווה קו בתור הגישה של המעבד, מה שעשוי לגרום לכך שגישות מסוימות לא יושלמו.

- **השפעה על מעבדים אחרים**: אין הבטחה שהוצאה של מחסום זיכרון במעבד אחד תיצור השפעה ישירה על מעבד אחר או על כל חומרה אחרת במערכת. ההשפעה שיכולה להיות קיימת היא השפעה עקיפה, שבה המעבד השני יראה את ההשפעות של הגישה של המעבד הראשון, אך ראוי לציין את המגבלות בכך.

- **סדר ההשפעות ממעבדים אחרים**: אין ערובה לכך שמעבד יראה את סדר ההשפעות הנכון מהגישות של מעבד אחר, אפילו אם המעבד השני עושה שימוש במחסום זיכרון. כדי להבטיח זאת, גם המעבד הראשון וגם המעבד שני צריכים להשתמש במחסומי זיכרון תואמים.

- **התערבות חומרה**: אין ערובה לכך שחלק מתערבות חומרה, אשר אינה קשורה למעבד, לא יסדר מחדש את הגישה לזיכרון. אמנם מנגנוני קוהרנטיות cache אמורים להפיץ את ההשפעות העקיפות של מחסום זיכרון בין המעבדים, ישנם מקרים שבהם הם לא מבצעים זאת בסדר הנכון.

## מחסומים ב-x86


ב-x86 הוראת מחסום מבטיחה שכל הקריאות או הכתיבות שהתבצעו לפני שמחסום יושלמו במלואן לפני הקריאות או הכתיבות שמגיעות אחרי המחסום.

ההוראות `LFENCE`, `SFENCE` ו-`MFENCE` משמשות כמחסומים ייעודיים:

- מחסום **`SFENCE` (store fence)**: מחסום זה מבטיח שכל פעולות הכתיבה שבוצעו לפני ה-`SFENCE` (לפי סדר התוכנית) ייכתבו לזיכרון לפני כל כתיבה שתבוצע לאחר ה-`SFENCE`.

- מחסום **`LFENCE` (load fence)**: מחסום זה מבטיח שכל פעולות הקריאה שבוצעו לפני ה-`LFENCE` יושלמו לפני כל קריאה שתבוצע אחריו.

- מחסום **`MFENCE` (memory fence)**: הוראה זו מבטיחה שכל הגישה לזיכרון (קריאות וכתיבות) שהתבצעה לפני ה-`MFENCE` תושלם לפני כל גישה נוספת לזיכרון שתתבצע לאחר המחסום, בין אם מדובר בקריאה או בכתיבה.

בנוסף, הוראות serializing, הוראות IO, והוראות נעולות כמו `XCHG` (שנעולה במשתמע) יכולות לשמש גם כמחסומי קריאה/כתיבה.


## מחסומים ב-Power PC


### sync

המחסום `sync` מבטיח שכל ההוראות שנכתבו לפני הביצוע שלו יושלמו במלואן לפני שניתן יהיה לבצע הוראות נוספות אחריו (בסדר התוכנית). זאת אומרת, כל ההוראות המבוצעות בסדר התוכנית לפני `sync` חייבות להסתיים לפני שמתחילים לעבד הוראות חדשות, ובכך היא יוצרת מחסום שמונע את ביצוע ההוראות הבאות עד לסיום כל ההוראות הקודמות.

המחסום `sync` משמשת בדרך כלל לסנכרון בין מעבדים שונים או בין thread-ים שונים, הוא מספק ודאות כי כל ההוראות הקודמות הושלמו לפני שממשיכים עם ההוראות הבאות.
### lwsync

מחסום `lwsync`, או Lightweight Synchronize, הוא מחסום סנכרון המבטיח שסיום כל ההוראות המבוצעות לפני ביצוע `lwsync` יושלמו לפני שניתן יהיה לבצע הוראות store נוספות במעבד שביצוע את המחסום. בנוסף, הוא מבטיח שכל הוראות load שמבוצעות לפני הקריאה ל-`lwsync` יושלמו לפני שניתן יהיה לבצע הוראות load נוספות באותו מעבד.

היתרון המרכזי של `lwsync` הוא שהוא מאפשר סנכרון בין מספר מעבדים תוך השפעה מינימלית על ביצועי המערכת, מכיוון שהוא אינו מחייב המתנה לאישור (ack) מסוים ממעבדים אחרים. בצורה זו, `lwsync` תורם לייעול הביצועים של תוכניות במערכות מרובות מעבדים.


## מחסומים ב-Arm
 

ארכיטקטורת Armv8 מגדירה מחסומי זיכרון המספקים מגוון פונקציונליות:

- סידור הוראות load ו-store.
- השלמת הוראות load ו-store.
- סנכרון context.
- הגבלות על ספקולציות.

### מחסום זיכרון נתונים (`DMB`)

הוראת `DMB` היא הוראת מחסום זיכרון שנועדה להבטיח סדר יחסי בין גישת זיכרון המתרחשת לפני המחסום לבין גישת זיכרון המתרחשת אחריו. עם זאת, יש לציין כי הוראת `DMB` אינה מבטיחה את השלמתן של הגישות לזיכרון שהיא משפיעה עליהן.

העקרון המרכזי של הוראת `DMB` הוא ליצור סדר בין גישות לזיכרון שהוגדרו להיות מושפעות על ידי אפשרויות `DMB`, אשר נמסרות כארגומנטים להוראה. הוראת `DMB` מבטיחה שכל גישה לזיכרון, המושפעת על ידי המעבד המבצע את הוראת `DMB`, שהופיעה בסדר התוכנית לפני הוראת ה-`DMB`, כמו גם גישות לזיכרון שמקורן במעבד אחר, נצפו על ידי המעבד. גישות אלה ידרשו להיות מושלמות במידה הנדרשת על ידי אפשרויות ה-`DMB` לפני כל גישה משפיעה לזיכרון, המתרחשת בסדר התוכנית לאחר הוראת ה-`DMB`.

להלן מידע נוסף על הוראת DMB:

- עבור ה-`DMB`, פעולות תחזוקת data cache נחשבות להוראות גישה מפורשות לנתונים, וכפופות להגבלות הסדר המוטלות על ידי ה-`DMB`. הוראת `DMB` שנועדה לאכוף את סדר הוראות תחזוקת ה-cache חייבת לציין ארגומנט הכולל גם loads וגם stores.

- מחסום `DMB` אינו קובע מתי בדיוק מתרחשות הגישות. מה שה-`DMB` מבטיח הוא שכאשר הגישה אכן מתבצעת, חלות המגבלות על סדר הפעולות המוטלות על ידי המחסום והארגומנטים הקשורים אליו. עם זאת, ה-`DMB` מאפשר למעבד להמשיך בביצוע פעולות אחרות בזמן שהנתונים המפורשים מחכים להשלמה.

- מחסום `DMB` אינו מונע קריאת נתונים מפורשים עתידיים מביצוע ספקולטיבי. אם מתבצעת קריאה ספקולטיבית, ה-core חייבת לזרוק את הנתונים הספקולטיביים הנמצאים ברגיסטר. ה-core נדרש גם לבצע מחדש את טעינת הנתונים לאחר שכל הגישה הקודמת לנתונים המפורשים נצפתה.

- מחסום זה לא משפיע על שליפות הוראות.

#### דוגמה 1: סידור מחדש

הקוד הבא מדגים את האפשרות לסידור מחדש של פעולות זיכרון, כפי שמתיר מודל זיכרון עם סדר חלש. בשלב הראשון, המיקומים בזיכרון המיוצגים על ידי `X1` ו-`X3` מאותחלים לערך `0`:


```asm {linenos=inline}
STR , [X1] 
STR , [X3]  ; Might be observed before the previous STR.
```

כאן, הכתיבה ל-`X3` עשויה להיראות כאילו היא מתבצעת לפני הכתיבה הקודמת ל-`X1`.

בדוגמה זו, המערכת יכולה לעדכן ולקרוא את המיקום בזיכרון של `X3` לפני שהמיקום בזיכרון של `X1` מעודכן. אם נניח שמצוי מעבד אחר הקורא את שני מיקומי הזיכרון באותו סדר, הטבלה הבאה ממחישה את השילובים האפשריים של הערכים שיכולים להתקבל:

|X1|X3|
|---|---|
|0x0|0x0|
|0x0|0x1|
|0x1|0x0|
|0x1|0x1|
#### דוגמה 2: מחסום המונע סידור מחדש

בדוגמה הבאה, נעשה שימוש בהוראת `DMB` כדי לאכוף את תצפית הפקודה, כאשר מיקומי הזיכרון ב-`X1` ו-`X3` מאותחלים ל-`0x0`:


```asm {linenos=inline}
STR , [X1]
DMB
STR , [X3]  ; Cannot observe this STR without first observing the previous STR.
```

בדוגמה זו, אם מיקום הזיכרון ב-`X3` מתעדכן, אז יש להבטיח שגם `X1` מעודכן. אם נניח שמעבד אחר קורא את שני מיקומי הזיכרון באותו סדר, הטבלה הבאה מציגה את השילובים המותרים של הערכים שיכולים להתקבל:

|X1|X3|
|---|---|
|0x0|0x0|
|0x1|0x0|
|0x1|0x1|

### מחסום סנכרון נתונים (`DSB`)

המחסום `DSB` הוא הוראת מחסום זיכרון שמבטיחה שכל גישות לזיכרון המתרחשות לפני סיום הוראת ה-`DSB` יושלמו לפני שההוראת המחסום עצמה תושלם. בכך, `DSB` מהווה מחסום חזק יותר בהשוואה ל-`DMB`, וכל סדר ש-`DMB` קובע עם ארגומנטים מסוימים נשמר גם על ידי ה-`DSB` כאשר משתמשים באותם ארגומנטים.

ההשלמה של הוראת `DSB`, המבוצעת על ידי מעבד P0, מתרחשת כאשר מתקיימים כל התנאים הבאים:

- כל האפקטים המפורשים של הגישות לזיכרון המופיעות בסדר התוכנית לפני הוראת ה-`DSB` הושלמו עבור כל רכיבי העיבוד בדומיין השיתוף הנדרש.

- אם סוגי הגישות הנדרשות על ידי ה-`DSB` כוללים גם קריאות וגם כתיבות, כל ההוראות שהונפקו על ידי המעבד P0 (המעבד שמבצע את המחסום) לפני ה-`DSB` חייבות להתבצע עבור הדומיין הנדרש:
	- כל הוראות תחזוקת ה-cache.
	- כל הוראות תחזוקת TLB.



בנוסף לכך, לא ניתן לשנות כל מצב של המערכת או לבצע כל פונקציה לאחר הוראת ה-`DSB` עד שהמחסום הושלם, למעט:

- שליפת הוראות ופענוח הוראות.






הדוגמה הבאה ממחישה את הכללים הנלווים ל-DSB:

```asm {linenos=inline}
STR X0, [X1]     ; Must complete before the DSB can retire. 
DSB 
ADD X1, X2, X3   ; Must NOT be executed before the first STR completes.
STR X4, [X5]     ; Must NOT be executed until the first STR completes.
```

במהלך רצף זה, מגבלות הסדר שהוטלו על ידי ה-DSB מבטיחות שההוראות `STR` וההוראת `ADD` השנייה לא יבוצעו עד שההוראה הקודמת `STR` תושלם וה-DSB יפרוש (retires).

#### מתי נחשבת גישה כמושלמת (complete)?

ה-`DSB` מבטיח שכל גישה קודמת לזיכרון תושלם לפני שההוראה `DSB` עצמה יכולה להסתיים, וזאת בהתאם לארגומנטים המיועדים. אך מהו המועד שבו גישה לזיכרון נחשבת למושלמת?

ההסבר להשלמת קריאה הוא פשוט יותר בהשוואה להשלמת כתיבה. הסיבה לכך היא שהשלמת קריאה מתבצעת כאשר הנתונים שנקראו מועברים לרגיסטרים של המעבד.

בניגוד להשלמת קריאה, השלמת כתיבה היא תהליך מורכב יותר. עבור כתיבות לזיכרון device, הנקודה שבה נחשבת הכתיבה כהושלמה תלויה במנגנון של Early-write acknowledgment המיועד לסוג הזיכרון. אם מערכת הזיכרון תומכת ב-EWA, אז ה-`DSB` יכול להסתיים לפני שהכתיבה תגיע לנקודת קצה (הציוד ההיקפי). לעומת זאת, כתיבה לזיכרון המוגדר כ-nGnRnE יכולה להיחשב כהושלמה רק כאשר מתקבלת תגובת כתיבה מהציוד ההיקפי.

בדוגמה הבאה, ה-`DSB` מעכב (stall) את הביצוע עד שה-`STR` לזיכרון Device-nGnRnE  יקבל תגובת כתיבה מהקצה ההיקפי במיקום הזיכרון המתאים:


```asm {linenos=inline}
STR X0, [Device-nGnRnE]  ; Must receive a write response from the end-peripheral

DSB SY  
```

בקטע זה, הדגש הוא על הצורך לקבל תגובת כתיבה מהקצה ההיקפי כדי שה-DSB יוכל להסתיים.

#### רכיבי עיבוד (Observers) שונים בארכיטקטורת AArch64

בארכיטקטורת AArch64, אין דרישה לסדר מסוים בין גישות שמבוצעות על ידי מעבדים שונים, גם אם קיימת תלות כתובות. לדוגמה, הקוד הבא יכול להתבצע ולהשלים בכל סדר, למרות שיש תלות כתובת בגלל שה-instruction cache וה-data cache שני רכיבי עיבוד (observers) שונים:

```asm {linenos=inline}
DC CVAU, X0 ; Operations are executed in any order
IC IVAU, X0 ; despite address dependency.  
```

אם הוראות אלו מסודרות מחדש, יתכן שה-instruction cache יתמלא בנתונים ישנים מה-data cache מה שיכול לגרום לבעיות עקב תצוגה שגויה של הנתונים. כדי למנוע בעיה זו, הארכיטקטורה דורשת שימוש במחסום זיכרון. דוגמה לכך מוצגת בקוד הבא:

```asm {linenos=inline}
DC CVAU, X0 ; Operations are executed in any order
DSB ISH
IC IVAU, X0 ; despite address dependency.  
```

בדוגמה זו, ההוראה `DC CVAU`, שמנקה את ה-data cache, חייבת להשלים לפני ביצוע ההוראה `IC IVAU`, שמבצעת ביטול של instruction cache . השימוש ב-`DC CVAU` מבטיח שהנתונים החדשים יהיו זמינים ל-instruction cache לפני שניתן לבצע את הביטול.

הערה:
	יש צורך בהוראת `DSB` כי ה-`DMB` משפיע רק על גישות לנתונים. זה כולל את הפעולת תחזוקת data cache, אך אינו מכסה את ההוראה לביטול ה-cache.

### מחסום סנכרון הוראות (`ISB`)

במקרים מסוימים, במיוחד בעקבות פעולות cache, ייתכן שההוראות ב-instruction queue יהיו ישנות או לא עדכניות, ויש צורך לנקות אותן לפני שהמעבד יכול להמשיך לפעול. הוראת `isb` נועדה בדיוק למטרה זו. 

הוראת `ISB` מבטיחה שכל ההוראות המגיעות לאחר הוראת ה-`ISB` לפי סדר התוכנית יישלפו (fetch) מה-cache או מהזיכרון רק לאחר סיום הוראת ה-`ISB`. השימוש ב-`ISB` מבטיח שההשפעות של פעולות שינוי context שבוצעו לפני ה-`ISB` יהיו גלויות להוראות שנשלפו לאחר מכן. 

באמצעות ה-`ISB`, ה-pipeline נשטף, מה שמבטיח שהשפעות כל פעולה שמשנה את context שבוצעה לפני ה-`ISB` יהיו גלויות לכל הוראה שתבוא לאחריו. כך, הוראות שיגיעו מה-cache או מהזיכרון ישלפו מחדש.

הוראה זו גם מבטיחה שכל פעולות שמשנות את ה-context לאחר ה-`ISB` ייכנסו לתוקף רק לאחר שההוראה הושלמה, ולכן אינן מובטחות להיות נראות בהוראות שמופיעות לפני ה-`ISB`.

דוגמאות לפעולות משנות context, שדורשות הוספת הוראת `ISB` כדי להבטיח שהשפעותיהן יהיו גלויות להוראות שנשלפות לאחר הוראת ה-`ISB`, כוללות:

- הוראות תחזוקה של cache ו-TLB מלאים.
- שינויים ברגיסטרי מערכת.

כל פעולות שינוי context המופיעות בסדר התוכנית לאחר הוראת ה-`ISB` נכנסות לתוקף רק לאחר ביצוע ה-`ISB`.
#### שינוי context

ארכיטקטורת ARM מגדירה את ה-context של המעבד כמצב ה-cache, ה-TLB ורגיסטרי המערכת. ביצוע פעולות תחזוקה עבור cache או TLB, או עדכון של רגיסטרי מערכת נחשבים לפעולות שמשנות את ההקשר (context-switching).

הארכיטקטורה מבטיחה כי כל פעולה שמשנה את ה-context תיראה לאחר אירוע של סינכרון context. הדרישה לסנכרון מפורש מקלה על מעצבי המעבדים, שכן היא מספקת את האפשרות להפיץ את שינויי ה-context בצורה לא מתמדת בכל מחזור. סנכרון מרומז יוצר תקורה מיותרת, ולכן דרישת אירוע סינכרון context מאפשרת לתוכנה לקבוע במפורש מתי היא רוצה שההקשר החדש יחול.

אירוע סינכרון context יכול להתבצע על ידי אחת מהפעולות הבאות:

- ביצוע פעולת `ISB`
- לקיחת Exception
- חזרה מ-Exception
- יציאה ממצב Debug

הערה:
	מימושי מעבד ARM אינם רשאים לעדכן את ה-context שלהם עבור ביצועים עתידיים אם המעבד לא מבצע אירוע סינכרון context.

ביצוע אירוע סינכרון context מבטיח את הדברים הבאים:

- כל ה-unmasked interrupts מחכים בזמן אירוע סינכרון context, ונלקחים לפני ההוראה הראשונה לאחר אירוע הסינכרון.

- אין הוראות המופיעות בסדר התוכנית לאחר הוראה שגורמת לאירוע סינכרון context והוראות לא יכולות לבצע כל חלק מהפונקציונליות שלהן עד שאירוע הסינכרון התרחש.

- כל הכתיבות לרגיסטרים של המערכת שמתבצעות לפני אירוע סינכרון ה-context משפיעות על כל הוראה המופיעה בסדר התוכנית אחרי ההוראה שגרמה לאירוע סינכרון ה-context.

- כל השינויים שהושלמו בטבלאות התרגום עבור ערכים שנעשו בהם שינויים אינם מורשים להיות מאוחסנים ב-cache ב-TLB, משפיעים על כל שליפות הפקודות המתרחשות לאחר הוראה שגרמה לאירוע סינכרון ה-context.

- כל ביטול (invalidation) של TLBs, cache הוראות, ובמצב AArch32, מנבאי branch-ים, שהושלמו לפני אירוע סינכרון ה-context, משפיעים על כל ההוראות המופיעות בסדר התוכנית לאחר הוראה שגרמה לאירוע סינכרון context.



### מחסום ספקולציה (`SB`)
 

הוראת `SB` מהווה מחסום זיכרון שמונע ביצוע ספקולטיבי של הוראות עד להשלמת המחסום. כאשר מדובר בהוראות אלה, ניתן היה לצפות בהן דרך ערוצים צדדיים.



בזמן שהמחסום לא הושלם, אין אפשרות לבצע ביצוע ספקולטיבי של הוראות המופיעות מאוחר יותר בסדר התוכנית, במידה שניתן לצפות בהן דרך ערוצים צדדיים, כתוצאה מספקולציה של זרימת בקרה או ספקולציה של ערכי נתונים. דוגמה לכך היא כאשר מתבצעת הקצאה ספקולטיבית עבור כל מבנה cache, כאשר ההקצאה של ערך מסוים יכולה להעיד על כל ערך נתונים הקיים בזיכרון או ברגיסטרים.

- אין לבצע ספקולציות במידה שניתן לחזות אותן דרך ערוצים צדדיים, בשל ספקולציות של זרימת בקרה או ספקולציות של ערכי נתונים.

- ניתן לבצע ספקולציה במקרה שבו מתבצע חיזוי שההוראה שעלולה להוביל ל-exception לא גורמת בביצוע עצמו ל-exception.

לא ניתן לבצע ביצוע ספקולטיבי של הוראת `SB` כתוצאה מהדברים הבאים:

- ספקולציות של זרימת בקרה.
- ספקולציה של ערכי נתונים.
- חיזוי שההוראה שיכולה להוביל ל-exception אינה אכן יוצרת exception.

הוראת `SB` יכולה להיחשב כהשולמה כאשר מתקיימים כל התנאים הבאים:

- ידוע שהיא אינה ספקולטיבית, או שהיא ספקולטיבית רק כתוצאה מאחת מהאפשרויות הבאות:

	- ספקולציה שההוראה שעלולה להוביל ל-exception ואינה גורמת ל-exception.
	- ספקולציות המתרחשות מעבר לנקודה בזרם הביצוע שבה נלקח exception אסינכרוני מדויק.
- כל ערכי הנתונים המיוצרים על ידי הוראות המופיעות בסדר התוכנית לפני הוראת `SB` נפתרו מבחינה ארכיטקטונית, ולכן אינם ספקולטיביים.


הערה:
	להוראת `SB` אין השפעה על השימוש במשאבי חיזוי לצורך חיזוי זרם הפקודות המופק, כל עוד החיזוי אינו מתבסס על נתונים שנלקחו מפלטי הרגיסטר של ביצוע ספקולטיבי של הוראות המופיעות בסדר התוכנית לאחר הוראת `SB`.

### הגבלת ה-scope של מחסומי הזיכרון

ההוראות `DMB` ו-`DSB` מקבלות ארגומנט המגדיר את סוג הגישה לזיכרון המוסדרת על ידי מחסום הזיכרון ואת דומיין השיתוף שעליו ההוראה פועלת. ה-scope הזה מגדיר למעשה את קבוצת המעבדים שעליהם חלים ההגבלות המוטלות על ידי המחסומים.

יכולת הגבלת ה-scope של מחסום הזיכרון היא שימושית במיוחד כאשר מנסים לייעל את ההשפעות של מחסומי זיכרון. במקרים מסוימים, מגבלות הסדר המלאות שמוטלות על ידי מחסום עשויות להיות מגבילות מדי, דבר שיכול להשפיע על ביצועי המערכת. הגבלת ה-scope של המחסום לקבוצת משנה של גישות לזיכרון ומעבדים עשויה לאפשר אופטימיזציות במיקרו-ארכיטקטורה, אשר יכולות להפחית את ההשפעות השליליות של מחסומי הזיכרון על הביצועים.

הערה:  
	בארכיטקטורת Armv8-A AArch64, יש צורך להגדיר באופן מפורש את הארגומנט בעת תכנות הוראות `DSB` או `DMB`. דרישה זו שונה מגרסאות קודמות של הארכיטקטורה, שבהן ברירת המחדל הייתה האפשרות `SY` במקרה שלא הוזן ארגומנט מפורש.

הטבלה הבאה מציגה את הארגומנטים התקפים עבור `DSB` ו-`DMB`:

| Argument | Ordered Accesses (Before-After) | Shareability Domain |
| -------- | ------------------------------- | ------------------- |
| `NSHLD`  | Load-Load, Load-Store           | Non-shareable       |
| `NSHST`  | Store-Store                     | Non-shareable       |
| `NSH`    | Any-Any                         | Non-shareable       |
| `ISHLD`  | Load-Load, Load-Store           | Inner Shareable     |
| `ISHST`  | Store-Store                     | Inner Shareable     |
| `ISH`    | Any-Any                         | Inner Shareable     |
| `OSHLD`  | Load-Load, Load-Store           | Outer Shareable     |
| `OSHST`  | Store-Store                     | Outer Shareable     |
| `OSH`    | Any-Any                         | Outer Shareable     |
| `LD`     | Load-Load, Load-Store           | Full System         |
| `ST`     | Store-Store                     | Full System         |
| `SY`     | Any-Any                         | Full System         |

למשל, כאשר משתמשים בהוראת `DMB ISHST`, ההשפעה חלה רק על הסדר של הוראות store המפורשות. סדר ההוראות של load שסביב המחסום אינו מושפע מההוראה. כמו כן, ה-`DMB` הזה מבצע אכיפה רק על הפקודות הנצפות עבור המעבדים השייכים לאותו דומיין שיתוף פנימי שבו פועל המעבד שמבצע את ה-`DMB`.
#### דוגמה להגבלת ה-scope של מחסומי זיכרון

נשקול את הקוד הבא שרץ במעבד P0:


```asm {linenos=inline}
LDR x0, [X4]  ; Can be observed out-of-order 
STR , [X1]
DMB ISHST
STR , [X3]
```

במקרה זה, הפרמטר `ISHST` מגביל את המחסום רק לדומיין Inner Shareable ולהוראות store. אם המעבד P0 והמעבד P1 אינם נמצאים באותו דומיין שיתוף פנימי, אז על פי ההגדרות הארכיטקטוניות, המעבד P1 יכול לראות את העדכון במיקום הזיכרון ב-`X3` לפני שהעדכון במיקום הזיכרון ב-`X1` הושלם. יתרה מכך, ההוראה `LDR` שקוראת מ-`X4` עשויה להיתפס מחוץ לסדר ביחס לקריאות למיקומים `X1` ו-`X3` על ידי כל המעבדים, כולל P0.

ההקלות הללו על הסדר המוטל על גישות הזיכרון עשויות להפחית את העומס הנדרש כאשר יש לכפות סדר צפייה במערכת.

### Multi-copy atomicity & Barriers


מערכת multi-copy atomicity אינה זקוקה לשימוש במחסומים. משמעות הדבר היא שהקוד לא יכול להבחין אם ישנם מחסומים המופצים בכל הנוגע לסידור ההוראות, ובסיסי הסידור שמספקים המחסומים נשמרים.

כדי להמחיש זאת, ניתן לראות רצף קוד לדוגמה:

```asm {linenos=inline}
STR [x0]
DSB OSH
SEV
```



במערכת multi-copy atomicity, כאשר המעבד P1 מבצע כתיבה, המעבד P2 יכול לראות את טרנזקציית הכתיבה ולקרוא את הערך שנכתב על ידי P1. מעבד P2 משתמש בהוראת `DSB OSH` כדי לקבוע מתי הכתיבה הושלמה. אם המחסום יושלם בתוך המעבד שהנפיק אותו (במקרה זה P2), ההשפעה של המחסום תתרחש בכל זאת. P2 מתבסס על תגובות מהכתיבה כדי לקבוע מתי טרנזקציות חיצוניות הושלמו והפכו לניתנות לצפייה, וכך יכול המחסום להיחשב כשלם.

במערכת non-multi-copy atomicity, ההנחה הזו אינה תקפה. אם נשתמש באותה דוגמת קוד, מערכת עם forwarding buffer, יכול להיות מצב שבו מעבד מאמין שהכתיבה שלו הושלמה (ולכן היא נראית לכל המעבדים הרלוונטיים), אך למעשה הכתיבה אינה נראית למעבדים אחרים. אם המעבד היה מסיים מחסום באופן פנימי, התוצאה עלולה להוביל לכישלון בקוהרנטיות הנתונים.

במקרה זה, המעבד יהיה חייב להפיץ מחסומים. המחסום יבטיח שהכתיבה תיראה עבור טרנזקציות שמתרחשות לאחר המחסום.

## LKMM

### סוגי מחסומים בקרנל

- **מחסומים חזקים**: מחסומים אלו, כמו smp_mb() ו-synchronize_rcu(), דורשים שהמעבד ישלים את כל ההוראות שקודמות למחסום לפני שהוא מבצע הוראות שאחריו. כלומר, כל ההוראות שקרו לפני המחסום חייבות להתבצע קודם.

- **מחסום `smp_rmb()`**: מחסום זה מיועד לקריאות, ומחייב את המעבד לבצע את כל הקריאות שקדמו למחסום לפני שהוא מבצע קריאות מאוחרות יותר.

- **מחסום `smp_wmb()`**: מחסום זה מיועד לכתיבות, ומבטיח שכל הכתיבות שקודמות למחסום יושלמו לפני הכתיבות המאוחרות יותר.



מחסומי זיכרון בדרך כלל מגיעים בזוגות. אם יש לשני תהליכים שיתוף פעולה וחשוב להם הסדר שבו נכתבים שני ערכים, אז הצד השני חייב להיות מודע באותה מידה לסדר שבו ערכים אלו נקראים.

הסיבה העיקרית לקיום של מספר סוגי מחסומי זיכרון היא שיקולי ביצועים. ביצוע של מחסום זיכרון מלא עשוי להיות פעולה יקרה, ומפתחי קרנל יעדיפו להימנע ממנו בנתיבי ביצוע מהירים. לעיתים, מחסומים חלשים יותר יהיו זולים יותר, במיוחד אם ניתן לוותר עליהם לחלוטין בארכיטקטורות מסוימות.

פרימיטיבים מסודרים לחלוטין מציבים מחסום מלא (`smp_mb`) לפני ואחרי הביצוע שלהם. הם מבטיחים שהפעולה הנוכחית תסודר כנגד כל פעולה אחרת שנעשית לפניה או אחריה, ובכך מספקים את הסדר המקסימלי שניתן להשיג בכל הנוגע לזיכרון.

#### שימוש במחסומי זיכרון `smp_wmb` ו-`smp_rmb`

בדרך כלל מומלץ להשתמש ב-`smp_store_release` ו-`smp_load_acquire` במקום ב-`smp_wmb` ו-`smp_rmb`, אך המחסומים הוותיקים יותר עדיין נמצאים בשימוש נרחב, ולכן הבנת אופן הפעולה שלהם חשובה.

בקוד הבא מתואר שימוש במחסומים `smp_wmb` ו-`smp_rmb` כדי להבטיח סדר זיכרון בין פעולות כתיבה וקריאה על שני מעבדים שונים:

 
```c {linenos=inline}
/* See MP+fencewmbonceonce+fencermbonceonce.litmus. */
void CPU0(void)
{
	WRITE_ONCE(x, 1);
	smp_wmb();
	WRITE_ONCE(y, 1);
}

void CPU1(void)
{
	r0 = READ_ONCE(y);
	smp_rmb();
	r1 = READ_ONCE(x);
}
```

כאן, `smp_wmb` מבטיח שכל פעולות הכתיבה הקודמות לו ב-CPU0 יתבצעו לפני פעולות הכתיבה המאוחרות לו, בעוד `smp_rmb` מבטיח שכל פעולות הקריאה הקודמות לו ב-CPU1 יתבצעו לפני הקריאות שאחריו. כך שאם `r0` שווה ל-1, כלומר `y` נכתבה ונקראה בהצלחה, אז גם `r1` יהיה חייב להיות 1, משום ש-`x` נכתב ב-CPU0 לפני `y`.

### מחסומים ייחודיים ב-LKMM

בקרנל יש מספר מחסומים מיוחדים הדורשים יחס סדר שונה במעט מהמחסום `smp_mb()`. בין מחסומים אלה כלולים `smp_mb__before_atomic()`, `smp_mb__after_atomic()`, ו-`smp_mb__after_spinlock()`. מחסומים אלה אינם מסדרים את כלל האירועים המוקדמים מול כלל האירועים המאוחרים, כפי ש-`smp_mb()` עושה, אלא יוצרים סדר מדויק בין סוגי פעולות מסוימות.

#### מחסומי `before` ו-`after`

פעולות על משתנים אטומיים, כגון פעולות מונה מסוג `atomic_t` המחזירות ערכים, חייבות להבטיח סדר זיכרון מוגדר באמצעות מחסומי זיכרון מסביב לביצוען. כל פעולת זיכרון המתרחשת לפני קריאת הפעולה האטומית צריכה להיות גלויה לכל המעבדים לפני שהפעולה האטומית עצמה תיראה גלויה. באופן דומה, יש להבטיח שהפעולה האטומית תהיה גלויה לכל המעבדים לפני כל פעולת זיכרון שתבוצע לאחריה.

המחסומים `smp_mb__before_atomic()` ו-`smp_mb__after_atomic()` מיועדים לשימוש יחד עם פעולות RMW אטומיות, שאינן כוללות מחסומי זיכרון באופן מובנה כמו פעולות ששמן מכיל את הסיומת `relaxed` ופעולות שלא מחזירות ערך. תפקידם הוא לספק את סדר פעולות הזיכרון הנדרש, במקרים בהם פעולות אטומיות מסוג RMW אינן כוללות מחסום זיכרון.

מחסומים אלו מתפקדים באופן דומה למחסום זיכרון מלא (`smp_mb`), אך לא בדיוק באותו אופן.

- ה- `smp_mb__before_atomic` מבטיח שכל הגישות לזיכרון שלפני הפעולה האטומית יישמרו בסדר הנכון עם הפעולה עצמה, ושהפעולה האטומית תבוצע לפני כל הגישות הבאות.

- ה-`smp_mb__after_atomic` מספק שמירה על סדר בין כל הגישות המאוחרות לפעולה האטומית לבין הפעולה עצמה, ומבטיח שהפעולה האטומית מתבצעת לאחר כל הגישות שקדמו לה.

- ה-`smp_mb__after_spinlock`  הוא עוד מחסום after אבל לא על פעולות אטומיות אלה על נעילת spinlock: הוא מסדר את פעולת רכישת מנעול וכל האירועים שהתרחשו לפניה מול כל האירועים הבאים כאשר נעשה שימוש במחסום זה לאחר פעולת רכישת מנעול.

חשוב לציין שגישה בין `smp_mb__{before,after}_atomic` לבין הפעולה האטומית עצמה לא נשמרת בסדר מסוים. לכן, יש להקפיד למקם את המחסום קרוב ככל הניתן לפעולה RMW האטומית כדי למנוע מצבים בלתי צפויים בסדר הפעולות.

מחסומים אלה חיוניים משום שלארכיטקטורות שונות יש סדרי ביצוע שונים עבור הפרימיטיבים האטומיים שלהן במצב SMP. לדוגמה, בארכיטקטורת TSO כמו x86, הפרימיטיבים האטומיים מסודרים במלואם, ולכן המחסומים הללו עשויים לא להתקיים בבינארי לאחר הקימפול.

יש להשתמש ב-`smp_mb__before_atomic` לפני הפעולה RMW אטומית שאינה מחזירה ערך, וב-`smp_mb__after_atomic` אחריה, כדי להבטיח את אותו סדר זיכרון שמספקות פעולות RMW אטומיות שמחזירות ערך.

לדוגמה, בקטע קוד:

```c {linenos=inline}
obj->dead = 1;
smp_mb__before_atomic();
atomic_dec(&obj->ref_count);
```

השימוש ב-`smp_mb__before_atomic` מבטיח שכל פעולות הזיכרון הקודמות לפעולה האטומית `atomic_dec()` יתבצעו בסדר הנדרש מבחינת כל המעבדים האחרים. בדוגמה זו, זה אומר שההשמה `obj->dead = 1` תהיה גלויה לכלל המעבדים לפני שהפחתת המונה `ref_count` תתבצע.

אם לא נשתמש במחסום `smp_mb__before_atomic`, המערכת עשויה באופן לגיטימי לעדכן את המונה האטומי כך שיראה גלוי למעבדים אחרים לפני השלמת ההשמה `obj->dead = 1`. חוסר במחסום זיכרון במקרים כאלה עלול לגרום להתנהגות בלתי צפויה ואפילו לתוצאות קריטיות, עקב סדר זיכרון שגוי.

##### דוגמה למימוש עם מחסומי זיכרון

הביטוי:
```c {linenos=inline}
atomic_fetch_add();
```

שקול לביטוי:

```c {linenos=inline}
smp_mb__before_atomic();
atomic_fetch_add_relaxed();
smp_mb__after_atomic();
```

הערה:
	ה-`atomic_fetch_add()` עשוי להיות מיושם בצורה יעילה יותר.


בדוגמה נוספת:

```c {linenos=inline}
smp_mb__before_atomic();
atomic_dec(&X);
```


נוצר תבנית דומה לפעולת release אך המחסום חזק יותר מ-release מכיוון שהוא מסדר את כל ההוראות שקדמו נגד הן קריאת והן כתיבת `atomic_dec()`, כמו גם נגד כל ההוראות שבאות אחריה.

בדוגמה הבאה:

```c {linenos=inline}
atomic_inc(&X);
smp_mb__after_atomic();
```

זהו דפוס acquire (אם כי לא אופייני בגלל שכאן יש פעולת כתיבה ולא קריאה), כאשר המחסום מספק שמירה על סדר חזק יותר מ-acquire, המבטיח שכל הגישות המאוחרות לפעולה יהיו מסודרות נגד הפעולה האטומית עצמה.
#### המחסום ברירת מחדל

אם לא מוגדר לאריכטקטורה מסוימת אז כברירת מחדל המחסומים `smp_mb__before_atomic` ו-`smp_mb__after_atomic` יהיו מחסום חזק:

`include/asm-generic/barrier.h`:
```c {linenos=inline}
 __smp_mb__before_atomic
 __smp_mb__before_atomic()	__smp_mb()


 __smp_mb__after_atomic
 __smp_mb__after_atomic()	__smp_mb()

```

#### מחסומים ב-bitops

ישנן שתי פעולות `bitops` מיוחדות בעלות סמנטיקה של מחסומי נעילה (lock) מסוג `acquire` ו-`release`, באופן דומה לסמנטיקה של ספינלוק (spinlock). פעולות אלו מתפקדות כמו הגרסאות הרגילות שלהן שאינן כוללות את הסיומות `_lock` או `_unlock`, אך הן מספקות במפורש את המשמעות של `acquire` או `release`. משמעות הדבר היא שהן מבטיחות את סדר פעולות הזיכרון הנדרש בעת השימוש בהן בניהול נעילות, וניתן להסתמך עליהן ליצירת סדר זה מבלי להוסיף מחסומי זיכרון נוספים:

```c {linenos=inline}
int test_and_set_bit_lock(unsigned long nr, unsigned long *addr);
void clear_bit_unlock(unsigned long nr, unsigned long *addr);
```

- ה-`test_and_set_bit_lock`: משמשת לניסיון להשיג נעילה על ביט מסוים. פעולה זו מבטיחה שכל פעולות הזיכרון שתבוצענה לאחריה יתבצעו רק לאחר שהיא תושלם, ובכך מבטיחה סדר acquire.

- ה-`clear_bit_unlock`: משמשת לשחרור הנעילה, ומבטיחה שכל פעולות הזיכרון הקודמות לה יושלמו לפני ביצועה, דבר שמאפשר סדר release.

כך, בשימוש עם `bit_spin_trylock` ו-`bit_spin_unlock`, פעולות אלה מספקות סדר תקין בזרימת זיכרון, בלי צורך במחסומי זיכרון נוספים, ומאפשרות ניהול יעיל של נעילות ברמת ביטים.

### מחסום קומפיילר

לקרנל יש פונקציה בשם `barrier()`, שמשמשת כמחסום קומפיילר ומונעת מהקומפיילר לסדר מחדש את גישת הזיכרון משני צדדי המחסום. משמעות הדבר היא שהקומפיילר לא יכול להעביר גישה לזיכרון מעבר ל-`barrier()`.


המחסום `barrier()` הוא מחסום כללי ואינו כולל גרסאות ייחודיות לגישות קריאה-קריאה או כתיבה-כתיבה. עם זאת, ניתן להתייחס לפונקציות `READ_ONCE()` ו-`WRITE_ONCE()` כצורות חלשות של מחסום, כאשר כל אחת מהן משפיעה רק על הגישה הספציפית שמסומנת בהן.

ההשפעות של פונקציית `barrier()` הן:

- **מניעת סידור מחדש**: הפונקציה מונעת מהקומפיילר לסדר מחדש גישה לזיכרון שתתרחש לאחר `barrier()`, כמו גם את הקדמת הגישה שנעשתה לפני `barrier()`. דוגמה לשימוש בהשפעה זו היא בהקלת התקשורת בין הקוד של interrupt-handler לבין הקוד שקיבל את ה-interrupt.

- **טעינת משתנים בלולאות**: כאשר `barrier()` נמצא בתוך לולאה, הוא מאלץ את הקומפיילר לטעון את המשתנים שבהם נעשה שימוש בלולאה בכל מעבר של הלולאה.

חשוב לציין שלמחסומי קומפיילר אלה אין השפעה ישירה על המעבד עצמו, אשר עשוי להחליט לסדר מחדש את הגישות לזיכרון לפי שיקוליו.

#### מחסומי זיכרון מעבד וקומפייר

כל מחסומי הזיכרון מרמזים על מחסום קומפיילר, במערכות עם מעבד יחיד, מחסומי הזיכרון SMP מצטמצמים בעיקר למחסומי קומפיילר, משום שההנחה היא שהמעבד יפעל באופן עקבי בעבודתו הפנימית, כלומר הוא יוכל לסדר את הגישות החופפות שלו לזיכרון בצורה נכונה ביחס לעצמו.

**חובה** להשתמש במחסומי זיכרון SMP על מנת לשלוט בסדר הגישות לזיכרון משותף במערכות SMP. במקרים מסוימים, ניתן להשתמש בנעילה כדי להשיג את אותה שליטה, אך זה לא תמיד מספיק.
### המודל האופרטיבי

המערכת מחולקת למעבדים ולתת-מערכת זיכרון. תפקידם של המעבדים הוא לבצע הוראות, אך לא בהכרח בסדר בו הן מופיעות בתוכנית. התקשורת בין המעבדים לבין תת-מערכת הזיכרון היא הכרחית עבור פעולות מסוימות. פעולות בסיסיות של המעבד, כגון ביצועי הוראות פשוטות, נעשות פעמים רבות ללא צורך בתקשורת זו, אך פעולות כמו loads, stores ו-barriers כרוכות בכך.

לכל מעבד יש cache מקומי. כאשר מעבד מבצע store, המשמעות היא שהמידע נכתב קודם כל ל-cache המקומי של אותו מעבד. עם זאת, עיבוד ה-store על ידי ה-cache עשוי לקחת זמן, ולא ניתן להשתמש במידע שנכתב לצורך פעולת load עד שהכתיבה עוברת עיבוד. בארכיטקטורות רבות, ה-cache המקומי פועל בסדר FIFO, מה שמכתיב את עיכוב העיבוד.

ביצוע הוראת מחסום זיכרון אינו דורש מהמעבד לבצע פעולה מיוחדת מלבד להודיע לתת-מערכת הזיכרון על קיומו של המחסום. עם זאת, מחסומים אכן מגבילים את האופן שבו המעבד ותת-מערכת הזיכרון מטפלים בהוראות אחרות, בכך שהם משפיעים על הסדר שלהן.

ההשפעה של המחסום היא כפולה:

- המחסום כופה על המעבד לבצע הוראות בסדר מסוים.
- הסדר המדויק שבו ההוראות מתבצעות תלוי בסוג המחסום שהוגדר:

מחסומים מסוימים משפיעים על הדרך שבה תת-מערכת הזיכרון מפיצה כתיבות בין מעבדים שונים. כאשר מעבד `P1` מבצע הוראת מחסום, יש לכך השפעה על האופן שבו stores מתפשטות למעבדים אחרים, כגון `P2`.

- במקרה של מחסום `smp_wmb()` שבוצע על ידי המעבד `P1`, המעבד `P2` יחויב לקבל את כל ה-stores שנעשו לפני המחסום ב-`P1` (לפי סדר התוכנית) לפני שהוא יקבל stores מאוחרים יותר מ-`P1`.

- אם store כלשהו כבר הופץ מ-`P1` ל-`P2` לפני מחסום release, אז כל ה-stores המוקדמים שבוצעו ב-`P1` יופצו גם הם ל-`P2` לפני ה-store שנעשה לאחר המחסום. במילים אחרות, המחסום release מבטיח שכל מה שנעשה לפניו יופץ תחילה.

- מחסום חזק מאלץ כל store שהופץ ל-`P1` לפני המחסום (כולל כל מה שנעשה מוקדם יותר לפי סדר התוכנית ב-`P1`) להתפשט לכל שאר המעבדים לפני ביצוע הוראות כלשהן שנעשות לאחר המחסום החזק ב-`P1`.

ההפצה (propagation) של כתיבות, הנאכפת על ידי מחסומי release ומחסומים חזקים, משפיעה על stores שנעשו במעבדים אחרים לפני המחסום וגם על אלו שבוצעו ב-`P1`. מחסומים אלה מוגדרים כ-A-cumulative, כלומר הם משפיעים על stores מכל המעבדים, הן מהמעבדים האחרים שמתפשטים ל-`P1`, והן מהכתיבות שנעשו ב-`P1` עצמו לפני המחסום.
לעומת זאת, מחסומי `smp_wmb()` אינם A-cumulative, כלומר הם משפיעים רק על ההפצה של stores שנעשו ב-`P1` עצמו לפני המחסום, ולא על כתיבות ממעבדים אחרים.


במודל הזיכרון החלש של הקרנל (בניגוד למודל החזק), אין תמיכה ב-B-cumulativity עבור מחסום הזיכרון `smp_wmb` וגם לא עבור רצפי פעולות של release-acquire. משמעות הדבר היא שפעולות כתיבה אינן נדרשות להופיע לפי סדר מחייב של הפצה גלובלית עבור כל המעבדים במערכת, לאחר ביצוע מחסומים אלה או ברצפים הללו.

עם זאת, המודל כן מספק תמיכה ב-A-cumulativity עבור מחסומי זיכרון חזקים (כגון `smp_mb`) וכן עבור פעולות store-release. ה-A-cumulativity מבטיחה שההשפעות של פעולות כתיבה מתבצעות בסדר מסוים על פני המעבדים, אך רק בהקשר של סדרי ה-release הקודמים.

בזכות כך, מבנה יחס hb הופך לפשוט יותר לעומת המודל החזק של LKMM, כיוון שהמודל החלש אינו מחייב מעקב או ניהול של סדרי הפצה מורכבים כמו אלו הנדרשים ב-B-cumulativity.


# Cumulativity

הצטברות (cumulativity), שמזכירה במידה מסוימת סדר סיבתי (causal), מתייחסת לסדר פעולות המוגדר על ידי מחסום זיכרון.

בחלק מהאכריטקטורות מחסום זיכרון לא רק משפיע על הסדר של פעולות של ה-thread שהפעיל אותו, אלא גם על פעולות של thread-ים אחרים. בפרט, הוא מבטיח שההשפעות של פעולות שנעשו על ידי thread אחד יתפשטו ויתחייבו לפני פעולות אחרות המתבצעות על ידי thread אחר.

המונח "התפשטות" (propagation) מתייחס לאופן שבו כתיבות לזיכרון מתפשטות לשאר ה-thread-ים במערכת, תוך הבטחה שהסדר שבו הכתיבות מופצות אינו סותר את סדר הקוהרנטיות.

מנקודת מבט מיקרו-ארכיטקטונית, מחסומים משמשים כדי לסדר את הפצת הכתיבות בין thread-ים שונים. יישום פשוט מאוד של גישה זו יכול להיות המתנה עד להשלמת כל הוראות הכתיבה שעדיין בביצוע (in-flight), ולאחר מכן להפיץ את הכתיבות למערכות השונות לפני שהמחסום עצמו מושלם. עם זאת, מערכות מודרניות כוללות פרוטוקולים מתקדמים יותר שמסייעים לסדר את הפצת הכתיבות בצורה יעילה יותר.

אנו אומרים שלמחסום יש השפעה מצטברת כאשר הוא מבטיח סדר התפשטות לא רק בין הכתיבה שמתבצעת על ידי ה-thread שמפעיל את המחסום, אלא גם בין כתיבות אחרות שמגיעות מ-thread-ים שאינם המבצע של המחסום.

לכל מחסום סדר התפשטות ישנן שתי קבוצות של הוראות המיועדות לו, הנקראות pre-set ו-post-set. קבוצות אלו משתנות בהתאם לסוג המחסום, אך כל המחסומים חולקים מספר תכונות בסיסיות:

- מחסום זיכרון אינו יכול להתחייב עד שכל ההוראות הנמצאות בקבוצת ה-pre-set שלו התחייבו.
- הוראה הנמצאת בקבוצת ה-post-set של המחסום אינה יכולה להתחייב או להתקיים עד שהמחסום עצמו התחייב.

כאשר מעבד מבצע מחסומי סדר התפשטות הוא מודיע לתת-מערכת הזיכרון על קיום המחסום. תת-מערכת הזיכרון, בתורה, מפיצה את המחסום לכל יתר המעבדים. בשלב זה נכנסות לתוקפן ההשפעות של סדר ההתפשטות של המחסום:

- תת-מערכת הזיכרון לא תבצע הפצה של מחסום למעבד מסוים עד שכל הכתיבות בקבוצת ה-pre-set של המחסום יופצו למעבד זה.
- תת-מערכת הזיכרון לא תבצע הפצה של כתיבה הנמצאת בקבוצת ה-post-set של מחסום למעבד כלשהו עד שהמחסום עצמו יופץ לאותו מעבד.

בכך, כל עוד הכתיבות שביצע המעבד לפני המחסום לא הושלמו, המחסום לא יתפשט, ולאחר מכן, כל עוד המחסום לא יופץ לשאר המעבדים, הכתיבות לאחר המחסום גם הן לא יתפשטו.

עקרון זה נכון גם לגבי הסדר שבו הכתיבה והמחסומים מגיעים לנקודת הקוהרנטיות. מבחינה זו, מחסומים נתפסים כמגיעים לנקודת הקוהרנטיות באופן דומה למעבד אחר. יתרה מכך, תת-מערכת הזיכרון אינה מזהה מחסום חזק עד שהוא התפשט לכל המעבדים והגיע לנקודת הקוהרנטיות. יש לציין כי עד שהמחסום לא הוכר, המעבד שמבצע את המחסום לא ימלא או יבצע כל הוראה לאחר המחסום החזק.
### מחסומי סדר התפשטות

מחסומי סדר התפשטות מתאפיינים בדרגות שונות של מצטברות (cumulative). משמעות הדבר היא שהמחסומים משפיעים לא רק על סדר ההפצות של כתיבות שהונפקו על ידי המעבד עצמו, אלא גם על סדר ההפצות של כתיבות שהונפקו על ידי מעבדים אחרים.

מחסום זיכרון חזק (נקרא גם מחסום מלא) חייב להתפשט לכל המעבדים לפני שהוא יכול מאושר (מקבל ack מתת מערכת הזיכרון). הוא מחויב להתפשט לכל המעבדים ורק לאחר מכן הוא יכול לקבל את האישור.

ה-pre-sets וה-post-sets של המחסומים מורחבים בהתאם:

- ה-pre-set של מחסום בעל A-cumulative כולל את כל הכתיבות שהתפשטו למעבד שמבצע את המחסום לפני ביצועו.
- ה-post-set של מחסום בעל B-cumulative כולל את כל הגישות לזיכרון שביצע מעבד אחר לאחר שהמחסום התפשט אליו.

### Power cumulativity

בארכיטקטורת Power פעולות stores מתבצעות ביחס למעבדים אחרים, ולא ישירות ביחס לזיכרון. כלומר, פעולה של store שמתבצעת על ידי המעבד P1 **מתבצעת ביחס ל**מעבד P2 כאשר כל פעולות ה-load שנעשת על ידי המעבד P2 לאותה כתובת זיכרון תחזיק את הערך החדש שנכתב או ערך שנכתב על ידי store מאוחרת יותר. הן לא יחזירו את הערך הקודם שנדרס על ידי ה-store של P1. הארכיטקטורה מבטיחה שאם המעבד P1 משתמש במחסומים כדי לסדר את פעולות הכתיבה S1, S2, ו-S3, אז שלושת הכתיבות יתבצעו באותו סדר גם ביחס לכל מעבד אחר Pi. לעומת זאת, בהיעדר מחסומים, ייתכן ש-store S1 של המעבד P1 יתבצע ביחס ל-P2, אך לא בהכרח ביחס ל-P3. ארכיטקטורת Power אינה מבטיחה סדר זיכרון כולל.

בהסברים הבאים מעבד P1 מבצע מספר גישות זיכרון ולאחר מכן מבצע מחסום זיכרון:
#### קבוצת A כוללת:

קבוצת A (בהקשר של P1) מתייחסת לכל הגישות לזיכרון **שבוצעו ביחס ל-P1** לפני יצירת מחסום הזיכרון.

המשמעות של "בוצע ביחס ל-P1" כאן היא שכל כתיבה שהופצה ל-P1 ונקראה על ידי P1, כאילו הופכת להיות בסדר תכניות (program order) לפני מחסום הזיכרון. כלומר, אם P1 קרא את הערך שנכתב על ידי P0 לפני המחסום.

#### קבוצת B כוללת:

כל הגישות לזיכרון שביצעו מעבדים אחרים, אשר סודרו לאחר המחסום של P1, בהתאם לתלות נתונים, תלות בקרה, או מחסום אחר, ויש ליישם את  זה בצורה רקורסיבית קדימה. 

דוגמה לרקורסיביות של B-cumulativity בנוגע ל-stores ברצף הפעולות הבא:

1. מעבד 0 מבצע מחסום זיכרון ולאחר מכן מבצע store למשתנה `a`. ה-store הזה משתייך לקבוצה B של מחסום הזיכרון.

2. מעבד 1 מבצע load מ-`a` שמחזיר את הערך המאוחסן על ידי המעבד 0. ה-load של מעבד 1 וכל הפעולות שלו שמסודרות לאחר ה-load משתייכות לקבוצה B של מעבד 0 של מחסום הזיכרון.

3. מעבד 1 מבצע store למשתנה `b` המסודר לאחר ה-load מ-`a` (למשל, בהתאם לקוד או תלות בנתונים). לכן, ה-store הזה משתייך לקבוצה B של המחסום זיכרון של מעבד 0.

4. מעבד 2 מבצע load מ-`b` שמחזיר את הערך המאוחסן על ידי המעבד 1. ה-load של מעבד 2 וכל הפעולות של מעבד 1 שמסודרות לאחר ה-load משתייכות לקבוצה B של המחסום זיכרון של מעבד 0.

האופי הרקורסיבי של B-cumulativity מאפשר להרחיב את הרצף הזה ללא הגבלה.

בניגוד לכך, ל-A-cumulativity אין את הרקורסיה הזו. רק אותן פעולות שבוצעו ביחס ל-thread הספציפי המכיל את מחסום הזיכרון יהיו בקבוצה A של מחסום הזיכרון הזה. אין אפשרות לרקורסיה של A-cumulativity דרך loads של thread-ים אחרים; הרקורסיה הזו מוגבלת רק ל-B-cumulativity.

הערה:
	צריך לשים לב שהתיעוד של ARMv7 כן עושה רקורסיה בקבוצה A ולעומת זאת ב-PPC אין רקורסיה בקבוצה A.

#### מחסומים מצטברים

מחסום זיכרון נחשב ל-cumulative אם הוא מסדר גם גישות לזיכרון המבוצעות על ידי מעבדים ומנגנונים שאינם המעבד שביצע את המחסום.

##### כתיבות לא אטומיות

בארכיטקטורת POWER, כתיבה אינה חייבת להתפשט בצורה אטומית לכל שאר המעבדים במערכת. כלומר, ייתכן מצב שבו כתיבה מסוימת תתפשט ל-thread אחד, בעוד ש-thread אחר לא יראה את אותה כתיבה.

##### תכונה מצטברת של מחסומים

התכונה המצטברת של המחסומים קובעת את הסדר שבו כל הכתיבות שהתפשטו ל-thread שמפעיל את המחסום מתבצעות לפני כל כתיבה נוספת המתרחשת לאחר מכן בסדר התוכנית, וזאת בכל הנוגע לכל thread אחר במערכת.

##### מחסומים וכתיבות לא אטומיות

הסמנטיקה של מחסומי sync ו-lwsync במערכת POWER היא עדינה ומורכבת. ל-lwsync יש סמנטיקה מצטברת, אך הוספת lwsync בין שתי הוראות אינה מחזירה את עקביות הסדר הרציפה של ההוראות.

אנו תופסים את ההתנהגות הזו על ידי פיצול מחסומים לאירועי התפשטות מרובים, המקבילים לאירועי הכתיבה, כאשר אנו קובעים כללי סדר מתאימים עבורם. מחסום יכול להתפשט ל-thread מסוים רק כאשר כל הכתיבות בקבוצת A המצטברת של המחסום כבר התפשטו לאותו thread.


#### Applicable
כל מחסום מצטבר מספק סדר רק כלפי הגישות התפיסות (applicable) המתאימות לו.

ל-applicable יש משמעות משתנה בהתאם לסוג הוראת מחסום הזיכרון:

- **מחסום `sync`**: כאן, גם ה-loads וגם ה-stores נחשבים applicable. המחסום מספק סדר סיבתי מלא, כלומר עקביות רציפה מלאה.

- **מחסום `lwsync`**: ה-applicability במצב זה מוגבלת למקרים הבאים:
	1. פעולות loads קודמות ו-loads הבאות.
	2. פעולות stores קודמות ו-stores הבאות.
	3. פעולות loads קודמות ו-stores הבאות.
	
	כתוצאה מכך, stores קודמים ו-loads הבאים אינם נחשבים ל-"ישימים" במצב של `lwsync`, ולכן במחסום `lwsync` לא מסדר את הכתיבות בקבוצה A עם קריאות בקבוצה B.

- **מחסום `eieio`**: רק ה-store נחשב ל-applicable.

#### מחסום ה-lwsync

ההשפעה של מחסום ה-lwsync היא כפולה:

- ראשית, הוא מגביל את האפשרות לסדר מחדש של הוראות ב-thread שבו הוא מתבצע. כל הוראת גישה לזיכרון חייבת להסתיים לפני ביצוע ה-lwsync, ולאחר מכן יש לבצע את ה-lwsync לפני כל הוראת גישה לזיכרון הבאה בסדר התוכנית (במקרה של קריאה) או לפני ביצוע של commit (במקרה של כתיבה).

- האפקט השני של מחסום ה-lwsync מתייחס לסידור ההפצה של ה-stores. עבור כל מחסום lwsync, המודל של האופרטיבי עוקב אחר קבוצת ה-stores והמחסומים שבוצעו על ידי thread הנוכחי או התפשטו ל-thread הנוכחי לפני ביצוע המחסום. לפני שניתן להפיץ את ה-lwsync ל-thread אחר, יש להבטיח שכל הכתיבות בקבוצה זו, המוכנה קבוצה A, יופצו קודם לכן ל-thread הנוכחי. סדר ההפצה שנכפה על ידי ה-lwsync הוא טרנזיטיבי.

#### הדגמות cumulativity

##### WRC -  Write to Read Causality

הערה:
	המונח multi-copy atomicity במאמר הזה מתייחס באותו אופן גם ל-multi-copy atomicity וגם ל-ohter-multi-copy atomicity.

בארכיטקטורות המספקות multi-copy atomicity, נדרש סנכרון מינימלי כדי למנוע את ההתנהגות המתוארת ב-WRC. במקרה כזה, כאשר מעבד 1 רואה את הכתיבה למשתנה x, כתיבה זו זמינה גם למעבד 2. לכן, כדי לאסור על ההתנהגות של WRC, מספיק לשמור על הסדר הפנימי של ההוראות בכל מעבד, למשל ניתן להשיג את זה על ידי תלות בין כתובת.

לעומת זאת, בארכיטקטורות שאינן תומכות ב-multi-copy atomicity, אי-מניעת התנהגות WRC מחייבת לוודא שנראות הכתיבה של x שהתבצעה במעבד 0 תתפשט באופן ברור גם למעבד 1 וגם למעבד 2. תלות פשוטה לא מספיקה למטרה זו, שכן היא אינה מבטיחה cumulativity. לשם כך, יש צורך במחסום cumulative, כמו למשל lwsync.

![](Fig_11_The_write-to-read_causality_pattern_wrc_with_lightweight_fence_and_ppo_(forbidden)_.png)

המבחן ממחיש את A-cumulativity של lwsync במעבד 1.

המחסום במעבד 1 מאלץ את הכתיבה של x להתפשט לפני הכתיבה של y למעבד 2 גם אם הכתיבה לא מתבצעת על אותו מעבד שמבצע את המחסום.

מעבדים עשויים ליישם A-cumulativity בדרכים רבות ושונות. יישום אפשרי אחד של מחסומי A-cumulativity, היא שהמחסומים לא רק ימתינו לקריאה הקודמת (a באיור) שתתקיים, אלא גם שכל הערכים המעופשים עבור x יימחקו מהמערכת (למשל הערך 0 שנקרא על ידי e במעבד 2).

לפי המודל האופרטיבי אפשר להבין את המקרה יותר בקלות:
המחסום `lwsync` משפיע על ההפצה של הכתיבות שלו וגם על הכתיבות שהתפשטו אליו בכך שהוא מאלץ כל מעבד שמקבל את המחסום, לפני שהמחסום מסתיים הוא חייב לראות את כל הכתיבות שהתפשטו אל המעבד שביצע את המחסום, כלומר במקרה שלנו מעבד 1 הפעיל את המחסום ומעבד 2 ראה את הכתיבה c ל-`y` והוא היה חייב לפני זה לקבל את המחסום, ולפני שזה התרחש הוא היה חייב לקבל את הכתיבות שהתפשטו למעבד 1 לפני המחסום ולכן זה מחייב שהכתיבה a ל-`x` של מעבד 0 שנמצאת בקבוצה A של המחסום (בגלל שהקריאה b נמצאת בקבוצה A והקריאה מסופקת מהכתיבה a) תתפשט למעבד 2 לפני שהוא רואה את הכתיבה c ל-`y`.



##### ISA2


![](Fig_12_The_pattern_isa2_with_lighweight_fence_and_ppo_twice_(forbidden)_.png)

ארכיטקטורת Power זקוקה למחסום `lwsync` בין הכתיבות, ותלות כתובת או תלות בנתונים בין כל זוג קריאות (כלומר, ב-T1 וגם ב-T2).

התבנית isa2+lwfence+ppos ממחישה את B-cumulativity של lwsync ב-T0.

כאן הקריאות `e` ו-`f` של `z` ו-`x` לא יכולות לראות את הכתיבות `a` ו-`d` מחוץ לסדר זה קורה בגלל האופי הרקורסיבי של B-cumulativity שמכיל בתוכו את כל האירועים שמסודרים אחרי אירועים שנמצאים כבר בקבוצה B. 



### ARMv7 cumulativity

ארכיטקטורת ARMv7 מציעה מודל זיכרון שיש בו דמיון רב לארכיטקטורת IBM Power. בדומה ל-Power, גם ARMv7 אינה מבטיחה סדר זיכרון כולל, מה שמוביל לפוטנציאל להתנהגויות בלתי צפויות במצבים מסוימים. לארכיטקטורת ARM יש מגוון סוגים של מחסומים, כולל מחסום זיכרון נתונים, המסוגל לסדר את כל הגישות לזיכרון או להתמקד רק בגישות store.

עם המעבר לארכיטקטורת ARMv8, המודל של arm השתנה ולקח בחשבון את עקרון ה-multi-copy atomicity, המאפשר יצירת סדר זיכרון כולל.

#### מחסומים
##### DSB

המחסום DSB ייחשב כמושלם כאשר מתקיימים שני תנאים:

1. כל הגישה המפורשת לזיכרון שנצפתה על ידי המעבד המבצע (P0) לפני ביצוע ה-DSB, צריכה להיות מסוגי הגישה הנדרשים ולהיות נצפית על ידי צופים באותו דומיין שיתוף שנדרש עבור P0.

2. כל פעולות התחזוקה הנוגעות ל-cache, מנבא branch-ים ול-TLB שבוצעו על ידי P0 לפני ביצוע ה-DSB חייבות להסתיים עבור דומיין השיתוף שנדרש.

##### DMB

המחסום DMB יוצר שתי קבוצות גישה לזיכרון: קבוצה A וקבוצה B.
###### קבוצת A

אנו מפרשים את "נצפה על ידי" ב-ARMv7 כפי שאנו מפרשים את "בוצע ביחס ל" ב-Power.

- כל גישה מפורשת לזיכרון מסוגי הגישה הנדרשים, המבוצעת על ידי צופים (observers) הנמצאים באותו דומיין שיתוף כמו המעבד P0, אשר **נצפתה על ידי** P0 לפני ביצוע הוראת ה-DMB.

- כל הוראת load עם סוגי הגישה הנדרשים, **הנצפית על ידי** כל צופה אחר (נקרא לו P1), אשר נמצא באותו דומיין שיתוף כמו P0, ונצפתה לפני שהצופה P1 ביצע גישה לזיכרון שנחשבת לחלק מקבוצה A.

###### קבוצת B

קבוצת B כוללת:

- כל גישה מפורשת לזיכרון מסוגי הגישה הנדרשים המבוצעת על ידי P0, אשר מתרחשת בסדר תוכנית (program order) לאחר הוראת DMB.

- כל גישה מפורשת לזיכרון מסוגי הגישה הנדרשים על ידי כל צופה נתון (נקרא לו P1) באותו דומיין שיתוף כמו P0, אשר יכולה להתבצע רק לאחר ש-P1 נחשף ל-store שהוא חלק מקבוצה B.

כל צופה ששותף באותו דומיין שיתוף כמו P0 חייב לצפות בכל חברי קבוצת A לפני שהוא יכול לצפות באחד מחברי קבוצת B, בתנאי שחברי הקבוצות נדרשים להיות נצפים. התנאים הללו נקבעים לפי יכולת השיתוף של המערכת ומאפייני ה-cache של מיקומי הזיכרון שאליהם ניגשים חברי הקבוצות.

במצבים שבהם חברי קבוצת A וחברי קבוצת B מבצעים גישה לאותו התקן חיצוני הממופה בזיכרון (memory-mapped peripheral), כל חברי קבוצת A יהיו נגישים וגלויים בהתקן החיצוני לפני שחברי קבוצת B יהפכו לגלויים בו.

אנו מפרשים את קבוצת B ב-ARMv7 באותו אופן שבו פרשנו את קבוצת B ב-PowerPC, כלומר גישות שבוצעו אחרי פעולות מסוימות יוצרות רצף מחייב בין פעולות קריאה וכתיבה.

##### dmb sy

למחסום dmb sy יש לו תכונות מצטברות:

המחסום מסדר stores שה-thread שהפעיל את המחסום קורא מהן לפני המחסום (ביחס ל-stores שהוא מבצע אחרי המחסום), ובכך מקיים מה שנקרא A-cumulativity.

המחסום מסדר את ה-stores (מה-thread שהפעיל את המחסום) המתרחשות לפני המחסום, ביחס ל-stores (מכל thread) המופיעים באופן לוגי אחרי המחסום, מה שמכונה B-cumulativity.

##### dmb ld & dmb st

המחסום `dmb ld` אינו צריך להיות מצטבר בכל דרך שהיא.
בעוד ש-`dmb st` הוא אך רק מקיים B-cumulativity.