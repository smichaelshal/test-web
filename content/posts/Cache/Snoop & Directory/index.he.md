+++
Sources = [
"https://www.linkedin.com/advice/3/what-trade-offs-between-snooping-directory-based",
"https://en.wikipedia.org/wiki/Cache_coherence",
"https://pages.cs.wisc.edu/~markhill/papers/primer2020_2nd_edition.pdf",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-11"
categories = [

]
series = [

]
title = "Snoop & Directory"
+++
## פרוטוקול Snooping

מנגנון Snooping הוא מנגנון שבו כל אחד מה-cache-ים במערכת עוקב אחרי שורות כתובת מסוימות כדי לזהות אם שורות זיכרון ששמורות ב-cache שלו נגישות או משתנות על ידי מעבדים אחרים. פרוטוקולי קוהרנטיות כמו פרוטוקולי invalidate ופרוטוקולי update משתמשים במנגנון זה.

פרוטוקול snooping מתבסס על bus משותף שמחבר בין כל ה-cache-ים לבין הזיכרון הראשי. כאשר מעבד מבצע כתיבה ל-cache שלו, הוא משדר את הכתובת של הבלוק שעבר שינוי אל ה-bus. מעבדים אחרים שברשותם עותק של אותו הבלוק ב-cache יכולים לבחור לבטל את העותק או לעדכן אותו, תלוי בגרסת הפרוטוקול שנמצאת בשימוש פרוטוקול מבוסס invalidate או מבוסס update). היתרון העיקרי של פרוטוקול זה הוא הפשטות והמהירות שלו, אך הוא מגיע עם מספר חסרונות:

-  ה-bus עלול להפוך לצוואר בקבוק ככל שמספר המעבדים והגישה ל-cache-ים גדלים.
- הפרוטוקול דורש שכל ה-cache-ים יעקבו כל הזמן אחר תעבורת ה-bus, דבר המוביל לצריכת חשמל ורוחב פס מוגבר.
- פרוטוקול זה אינו מתאים למערכות מבוזרות, שבהן ה-bus מוחלף ברשת תקשורת.

למרות החסרונות, הפרוטוקול עדיין מתאים לשימוש במערכות עם מספר קטן של מעבדים, שבהן הפשטות שלו עדיפה על מגבלותיו. כמו כן, הוא שימושי במערכות בזמן אמת או ביישומים שבהם יש צורך בגישה מהירה ועם חביון נמוך לנתונים משותפים.

### קוהרנטיות בפרוטוקולי snooping

פרוטוקולי snooping מבוססים על עיקרון מרכזי אחד: כל בקרי הקוהרנטיות עוקבים אחר בקשות הקוהרנטיות (snoop) בסדר אחיד, ופועלים בצורה מתואמת לשמירה על קוהרנטיות הנתונים במערכת. על ידי כך שכל הבקשות המתקבלות עבור בלוק נתון יופיעו לפי סדר קבוע, הפרוטוקול מאפשר לבקרי הקוהרנטיות המבוזרים לעדכן את מצבם באופן נכון, תוך התאמה למכונת המצבים המשותפת המתארת את המצב של בלוק ה-cache בכל רגע נתון.

בפרוטוקולי snooping מסורתיים, כל בקשה משודרת לכל בקרי הקוהרנטיות במערכת, כולל הבקר שיזם את הבקשה. בקשות אלה נשלחות לרוב דרך רשת שידור מסודרת, כמו bus, שמבטיחה שכל בקרי הקוהרנטיות יקבלו את הבקשות באותו סדר בדיוק. כלומר, נוצרת מערכת של סדר כולל לבקשות הקוהרנטיות, המבטיחה שכל בקר קוהרנטיות יצפה באותה סדרה של פעולות באותו רצף.

הסדר הכולל הזה מאפשר לכל בקר קוהרנטיות לעדכן בצורה מדויקת את המצב של בלוק ה-cache, מאחר שההחלטות מתבססות על אותה סדרת פעולות לכל הבקרים, ללא קשר למיקומם או לפעולות אחרות שמתרחשות במקביל במערכת.

### כיצד Snooping תלוי בסדר כולל של בקשות קוהרנטיות

פרוטוקולי Snooping מסורתיים מבוססים על קיומו של סדר כולל של כל בקשות הקוהרנטיות במערכת. הסדר הזה מאפשר לכל בקר קוהרנטיות לקבוע מתי בקשה מסוימת התקבלה, בהתבסס על סדר snooping לוגי שמסנכרן בין כל הבקרים.

היכולת של פרוטוקול snooping לזהות באופן עקיף את סדר הגעת הבקשות היא מה שמייחד אותו מפרוטוקולי directory, שבהם נדרש מעקב מפורש אחר כל בקשה.

כדי ליישם את הדרישה הזאת לסדר כולל, רשת interconnect בפרוטוקול snooping צריכה לארגן את כל בקשות הקוהרנטיות בסדר קבוע. מאחר שבקרים שונים יכולים להוציא בקשות בו-זמנית, הרשת חייבת לטפל בתעדוף וסידור הבקשות בנקודת הסדרה (serialization point). כאשר בקר קוהרנטיות שולח בקשת קוהרנטיות, רשת interconnect ממיינת את הבקשה, משדרת אותה לכל הבקרים, והבקר ששלח את הבקשה לומד מה סדר ההגעה שלה על ידי צפייה בזרם הבקשות שהוא מקבל.

למשל, מערכת המבוססת על bus משתמשת ב-bus עצמו לשידור מסודר של כל בקשות הקוהרנטיות. כל בקשה שנשלחת עוברת לכל הבקרים בסדר אחיד, מה שמקל על שמירת קוהרנטיות.

אולם, הדרישה לרשת שידור מסודרת עבור פרוטוקולי snooping הופכת את המימוש ליקר ולא יעיל בהשוואה לרשתות פשוטות וזולות יותר שיכולות לשרת פרוטוקולי directory. בפרט, במערכות גדולות עם מספר רב של ליבות, snooping יוצר צוואר בקבוק, הן מבחינת רוחב הפס של הרשת הנדרשת לשידור הבקשות, והן מבחינת העומס על בקרי הקוהרנטיות שצריכים לעקוב אחרי כל הבקשות. בשל כך, מערכות בעלות scalability דורשות פרוטוקול קוהרנטיות יעיל יותר, והצורך הזה הוביל לפיתוח פרוטוקולי directory.

עם זאת, snooping עדיין יכול להיות חלק מהפתרון גם במערכות גדולות. אחת הטכניקות היעילות ל-scalability היא "הפרד ומשול". לדוגמה, במערכת הכוללת שבבים מרובי ליבות, ניתן להשתמש בפרוטוקול snooping לשמירה על קוהרנטיות בתוך כל שבב, בעוד שפרוטוקול directory מטפל בקוהרנטיות בין השבבים. גישה זו מאפשרת לשלב בין היתרונות של שתי השיטות.


## פרוטוקול מבוסס Directory

בפרוטוקול מבוסס directory, ישנו רכיב מרכזי או מבוזר הנקרא directory, אשר אחראי לניהול המעקב אחר מצבם ומיקומם של כל בלוקי ה-cache במערכת. כאשר מעבד מבקש לקרוא או לכתוב בלוק מסוים ב-cache, הוא שולח בקשה ל-directory. ה-directory בודק את המידע על הבלוק ומחליט אם לאשר או לדחות את הבקשה, ובמידת הצורך, מאמת את התקשורת בין המעבד המבקש למעבדים אחרים שמחזיקים עותקים של הבלוק.

ה-directory פועל כמעין מתווך, וכל מעבד שמעוניין לטעון ערך מהזיכרון הראשי ל-cache שלו חייב לבקש רשות מה-directory.

כאשר ערך בזיכרון משתנה על ידי אחד מהמעבדים, ה-directory מעדכן את שאר ה-cache-ים שמחזיקים עותקים של אותו ערך, או לחלופין מבטל את תוקף העותקים שלהם, בהתאם לפרוטוקול הקוהרנטיות הנדרש. בכך ה-directory מבטיח שכל ה-cache-ים במערכת יישארו מסונכרנים וימנעו ממצבים של חוסר קוהרנטיות בנתונים.

פרוטוקול זה מצליח להתגבר על חלק מהמגבלות של פרוטוקול snooping:

- **הפחתת עומס תעבורה**: התעבורה ב-bus או ברשת מצטמצמת, מכיוון שרק המעבדים הרלוונטיים מעורבים בכל פעולה, ולא כל המעבדים במערכת כמו ב-snooping.
- **שיפור scalability**: ה-directory יכול להיות מבוזר על פני מספר צמתים, מה שמאפשר תמיכה במערכות גדולות יותר עם מספר רב של מעבדים.
- **גמישות**: ניתן ליישם מדיניות שונות עבור אזורי זיכרון שונים, בהתאם לצורכי היישום.

עם זאת, ישנם גם חסרונות לפרוטוקול מבוסס directory:

- **נקודת כשל מרכזית**: במערכות עם directory מרכזי, הרכיב מהווה נקודת תורפה בודדת. אם ה-directory הופך לבלתי זמין, בין אם עקב תקלת חומרה או בעיה אחרת, הדבר עלול לשבש את פעולתה של המערכת כולה.

### קוהרנטיות בפרוטוקולי Directory

פרוטוקולי directories נוצרו במטרה להתמודד עם המגבלות של פרוטוקולי snooping מבחינת scalability. בפרוטוקולי snooping מסורתיים, כל הבקשות מועברות דרך רשת חיבורית מסודרת, וכל בקרי הקוהרנטיות חייבים לעקוב ולעבד את כל הבקשות, מה שיוצר עומס כבד במערכות גדולות. לעומת זאת, פרוטוקולי directories מציעים גישה שונה שמבוססת על עקיפה, המאפשרת להימנע מהצורך ברשת שידור מסודרת ומהחובה שכל בקר cache יטפל בכל בקשה.

ה-directory עוקב אחרי ה-cache-ים המחזיקים בכל בלוק, ובאילו מצבים הם מחזיקים אותו (למשל, מצבי MESI). כאשר בקר cache רוצה לבצע בקשת קוהרנטיות, כמו בקשה לקריאת נתונים, הוא שולח את הבקשה ישירות ל-directory בהודעת unicast.

ה-directory בודק את מצב הבלוק המבוקש כדי לקבוע כיצד להמשיך. לדוגמה, אם ה-directory מזהה שהבלוק נמצא בבעלות של ליבה אחרת, נניח Core 2, הוא ינתב את הבקשה ישירות ל-Core 2, ויבקש מליבת Core 2 לשלוח עותק של הבלוק ל-cache המבקש. לאחר קבלת ההודעה, ה-cache של Core 2 ישיב עם הנתונים ל-cache שביצע את הבקשה.

הבדל מעניין בין פרוטוקולי directories לבין פרוטוקולי snooping הוא באופן הטיפול הבסיסי בבקשות. בעוד ש-snooping מסתמך על כך שכל הבקרים יתעדו את כל הבקשות ברשת מסודרת, פרוטוקולי directories עובדים בצורה ממוקדת יותר, כאשר כל בקשה מטופלת ישירות על ידי ה-directory והרכיבים הרלוונטיים, מה שמאפשר למערכת להיות scalability ויעילה יותר.

#### פרוטוקול Directory

בפרוטוקול directory, ה-directory אחראית לניהול מצב כל בלוק נתונים במערכת. כל בקשת קוהרנטיות שמגיעות מבקרי cache נשלחות ישירות ל-directory, אשר בוחנת את מצב הבלוק ומביאה החלטות בהתאם. בהתאם למצב, ה-directory עשויה או להגיב לבקשה בעצמה, או להעביר את הבקשה לבקרי קוהרנטיות נוספים, שיגיבו לאחר מכן.

טרנזקציות קוהרנטיות בפרוטוקול directory נוגעות בדרך כלל לשני סוגי שלבים:

1. **שני שלבים**: שלב בקשת unicast ולאחר מכן תגובת unicast.
2. **שלושה שלבים**: שלב בקשת unicast, שלב שבו הבקשה מועברת ל-K בקרי קוהרנטיות (כאשר K הוא מספר השותפים המהווים את ה-cache הנדרש), ולאחר מכן תגובות מ-K הבקרים.

בחלק מהפרוטוקולים קיימת גם אפשרות של שלב רביעי, לדוגמה, אם ה-directory מעורבת בתגובות עקיפות או אם המבקש מודיע ל-directory על סיום הטרנזקציה.

בניגוד לכך, בפרוטוקולי snooping, כל מצב הבלוק מופץ בין כל בקרי הקוהרנטיות במערכת. מכיוון שאין כאן מרכז ניהול של מצב בלוק, כל בקשה קוהרנטית נשלחת לכל הבקרים, מה שדורש שידור של הבקשה לכל בקר, ולאחר מכן קבלת תגובה unicast. כך, טרנזקציות קוהרנטיות ב-snooping כוללות תמיד שני שלבים: שלב בקשת שידור ושלב תגובה unicast.

כמו כן, גם בפרוטוקול directory, יש צורך להגדיר מתי וכיצד טרנזקציות קוהרנטיות מסודרות ביחס לטרנזקציות אחרות. ברוב פרוטוקולי ה-directory, הסדר של טרנזקציה נקבע לפי הסדר שבו הבקשות מסודרות ב-directory. כאשר מספר בקרי קוהרנטיות שולחים בקשות בו-זמנית, ה-directory קובעת את סדר העיבוד של הבקשות.

כאשר ישנן שתי בקשות מתחרות ל-directory, הרשת קובעת איזו בקשה תעובד קודם. ההתנהלות עם הבקשה השנייה תלויה בפרוטוקול הספציפי של ה-directory ובסוג הבקשות המתחרות. האפשרויות כוללות:

- **עיבוד מיד לאחר הבקשה הראשונה**: הבקשה השנייה מעובדת ברצף לאחר הראשונה.
- **שמירה בהמתנה**: הבקשה השנייה נשמרת ב-directory עד להשלמת הבקשה הראשונה.
- **אישור שלילי (NACK)**: ה-directory שולחת הודעת אישור שלילי למבקש, שמאלץ להנפיק מחדש את בקשתו.

השימוש ב-directory כנקודת סידור (ordering point) מדגיש הבדל מרכזי נוסף בין פרוטוקולי directory לפרוטוקולי snooping:

בפרוטוקולי snooping המסורתיים, הסדר הכולל של טרנזקציות נקבע על ידי סידור כל הבקשות ברשת השידור המסודרת לחלוטין. הסדר הכולל הזה אינו רק מבטיח שכל בקשה לבלוק נתון תעובד לפי סדר הגעתה, אלא גם מקל על ביצוע מודל עקביות זיכרון. 

כאשר בקשת קוהרנטיות נשלחת, היא מועברת לכולם באותו סדר, כך שכאשר בקר snooping מקבל את בקשת ה-ReadUnique (בפרוטוקול AMBA CHI) שלו, הוא יכול להסיק ש-cache-ים האחרים יבטלו את התוקף של הבלוקים במצב share אצלם. זה מאפשר לו לדעת מתי להתחיל עידן קוהרנטיות חדש.

לעומת זאת, בפרוטוקולי directory, הסדר של טרנזקציות קובע ה-directory, כדי להבטיח שבקשות סותרות יעובדו לפי סדר הגעתן בכל הצמתים. היעדר הסדר הכולל ברשת השידור פירושו שבקר בפרוטוקול directory נדרש ליישם אסטרטגיה נוספת כדי לקבוע מתי הבקשה שלו הוסדרה, ולמעשה, מתי הוא יכול להתחיל בעידן הקוהרנטיות שלו. מכיוון שרוב פרוטוקולי ה-directory אינם משתמשים בשידור מסודר לחלוטין, אין סדר גלובלי שניתן לעקוב אחריו. במקום זאת, כל בקשה צריכה להיות מסודרת באופן אינדיבידואלי ביחס לכל ה-cache-ים שיכולים להחזיק עותק של הבלוק. במקרה של בקשת ReadUnique, כל בקר cache שמחזיק עותק משותף חייב לשלוח הודעת אישור (Ack) מפורשת לאחר שהוא עיבד את הבקשה וסילק את התוקף מהעותקים שלו, על מנת להודיע למבקש שהבקשה שלו הוסדרה.


השוואת פרוטוקולי directory ו-snooping מדגישה את הפשרה הבסיסית ביניהם. פרוטוקול directory מציע scalability גבוהה יותר, כלומר הוא דורש פחות רוחב פס, אך זאת במחיר של רמת עקיפה גבוהה יותר. בפרוטוקולי directory, חלק מהטרנזקציות כוללות שלושה שלבים, בניגוד לשני שלבים בפרוטוקולי snooping, מה שמגביר את ההשהיה של חלק מהטרנזקציות הקוהרנטיות.

בפרוטוקול directory, קליטת הודעה יכולה להניע את בקר הקוהרנטיות לשלוח הודעה נוספת. באופן כללי, אם אירוע A (כגון קליטת הודעות) יכול לגרום לאירוע B (כגון שליחת הודעות), ושני האירועים הללו דורשים הקצאת משאבים (כמו קישורי רשת ו-buffer-ים), יש להיזהר מהתמודדות עם מצב של deadlock שעלול להתרחש אם נוצרות תלות מעגלית במשאבים, שבה כל רכיב מחכה למשאב שנמצא בבעלות רכיב אחר.
