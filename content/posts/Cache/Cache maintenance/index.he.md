+++
Sources = [
"https://developer.arm.com/documentation/den0024/a/Caches/Cache-maintenance",
"https://inria.hal.science/hal-02509910/document",
"https://developer.arm.com/documentation/ihi0050/latest/",
"https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf",
"https://developer.arm.com/documentation/107565/0101/Memory-system/Caches-and-memory-hierarchy/Implications-of-caches-for-programmers?lang=en",
"https://mariokartwii.com/armv8",
"https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/memory-access-ordering---an-introduction",
"https://documentation-service.arm.com/static/65fdad3c1bc22b03bca90781?token=",
"https://developer.arm.com/documentation/den0024/a/Caches/Point-of-coherency-and-unification",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-11"
categories = [

]
series = [

]
title = "Cache maintenance"
+++
## תחזוקת cache בתוכנה

לעיתים יש צורך בתוכנה לבצע פעולות ניקוי או ביטול של ה-cache. פעולות אלו נדרשות כאשר תוכן הזיכרון החיצוני השתנה, ויש צורך להבטיח שה-cache אינו מכיל נתונים מיושנים. פעולות אלו יכולות להיות נדרשות גם לאחר שינויים הקשורים ל-MMU כמו שינוי הרשאות גישה, מדיניות cache, מיפוי כתובות וירטואליות לכתובת פיזית, או כאשר ה-I-caches ו-D-caches חייבים להיות מסונכרנים לקוד שנוצר באופן דינמי, כגון ב-JIT-compilers וטועני ספריות דינמיות.

- ביטול (Invalidation) של cache או cache line: פעולה זו כוללת ניקוי של ה-cache מנתונים ללא כתיבה לרמה הבאה או לזיכרון הראשי על ידי ביטול של cache line אחת או יותר. משמעות הדבר היא שה-cache מסומן כ-invalid, ולכן תוכן השורות אינו מוגדר. אפשר לראות זאת כדרך להסיר שינויים בתחום הזיכרון מה-cache, כך שהנתונים המחודשים מהזיכרון החיצוני יכנסו ל-cache בצורה נכונה.

- ניקוי של cache line או cache: פעולה זו כוללת כתיבה של התוכן של שורות ה-cache המסומנות כמלוכלכות לרמה הבאה של ה-cache או ישירות לזיכרון הראשי, ולאחר מכן ניקוי ביט ה-dirty ב-cache line. פעולה זו מבטיחה שהתוכן של ה-cache line יהיה תואם עם הרמה הבאה של ה-cache או עם מערכת הזיכרון.

### פעולות תחזוקת cache והשפעתן

בנסיבות רגילות, פעולות של ניקוי או ביטול של כל ה-cache מתבצעות בעיקר על ידי ה-firmware כחלק מתהליך ההדלקה או הכיבוי של הליבה. תהליך זה עשוי לקחת זמן משמעותי, במיוחד כאשר מדובר ב-cache L2, שבו מספר השורות יכול להיות גדול מאוד. במקרה כזה, יש לעבור על כל השורות בלולאה אחת אחת, מה שיכול להאריך את זמן הביצוע.

## x86

### Cache Line Writeback and Flush

הוראת `CLFLUSH` מקבלת כתובת ומבצעת בדיקה האם הכתובת נמצאת ב-cache. אם הכתובת קיימת ב-cache, כל שורת ה-cache הכוללת את הכתובת נעשית לא חוקית. במקרה שחלק כלשהו מהשורה במצב מלוכלך (כלומר, modified או owned ב-MOESI), כל השורה נכתבת חזרה לזיכרון הראשי לפני שהיא מבוטלת. `CLFLUSH` משפיעה על כל ה-cache-ים שביררכיית הזיכרון, כולל ה-cache-ים הפנימיים וחיצוניים למעבד, וכן על כל הליבות במעבד. לעומת זאת, הוראת `CLWB` פועלת בצורה דומה, אך היא לא מבטלת את שורת ה-cache. התהליך של הבדיקה והביטול נמשך עד שהכתובת עודכנה בזיכרון, ובמקרה של `CLFLUSH`, עד שכל ה-cache-ים הקשורים בכתובת זו בוטלו.

באופן כללי, סוג הזיכרון הבסיסי שהוקצה לכתובת לא משפיע על אופן פעולת ההוראה הזו. עם זאת, כאשר סוג הזיכרון הבסיסי עבור הכתובת מוגדר כ-Uncacheable או Write Combining, המעבד לא ימשיך לבדוק את כל ה-cache-ים כדי לוודא אם הכתובת נמצאת בהם. במצבים אלו, הכתובת אינה ניתנת לשמירה והביטול של התוקף הוא מיותר. כמו כן, אם הכתובת הפיזית המתאימה נופלת בטווח הכתובת הפעילה של Write-Combining Buffer, הנתונים ב-buffer יכתבו חזרה לזיכרון.

### Cache Writeback and Invalidate

בניגוד להוראות `CLFLUSH` ו-`CLWB`, אשר פועלות על cache line בודדת, ההוראות `WBINVD` ו-`WBNOINVD` משפיעות על כל ה-cache במערכת. כאשר מופעלת הוראת `WBINVD`, היא מתחילה בכתיבה write-back של כל שורות ה-cache המלוכלכות (כלומר, שורות במצב modified או owned ב-MOESI) אל הזיכרון הראשי. הוראת `WBINVD` מבטלת גם את כל שורות ה-cache. תהליך זה נמשך עד שכל ה-cache-ים הפנימיים בנתיב של הליבה המבצעת לזיכרון המערכת מתבטלים. במצבים מסוימים, תהליך זה עשוי לכלול גם cache-ים ברמות אחרות בהיררכיית ה-cache של המערכת. לכל אחת מההוראות, מתבצע מחזור bus מיוחד שנשלח ל-cache-ים חיצוניים ברמות גבוהות יותר, כדי להנחות אותם לבצע פעולות כתיבה וביטול תוקף.

### Cache Invalidate

הוראת `INVD` מיועדת לבטל את כל שורות ה-cache. בניגוד להוראת `WBINVD`, הוראת `INVD` לא מבצעת כתיבה write-back של שורות ה-cache המלוכלכות אל הזיכרון הראשי. התהליך נמשך עד שכל ה-cache-ים הפנימיים בוטלו. בנוסף, מתבצע מחזור bus מיוחד המועבר ל-cache-ים חיצוניים ברמות גבוהות יותר, כדי להנחות אותם לבצע ביטול תוקף. יש להשתמש בהוראת `INVD` רק במצבים שבהם קוהרנטיות הזיכרון איננה נדרשת.

## Arm


ב-arm יש תבנית דומה לפעולות תחזוקת cache ל-data cache ול-instruction cache וכל פעולה כזאת מקבלת פרמטרים שבעזרתם ניתן לבצע את הפעולה לדיוק ולמיקום הנכון.

### סוג ה-cache

הדבר הראשון שצריך לבחור זה כמובן את סוג ה-cache שעליו רוצים להפעיל את הפעולה:

- פעולות על ה-data cache מתבצעות על ידי ההוראה `DC`
- פעולות על ה-instruction cache מתבצעות על ידי ההוראה `IC`
### סוג הפעולה

כמו ב-x86 גם ב-arm ניתן לבחור בין 2 פעולות על ה-cache-ים:
- ניקוי של cache line או cache (מסומן על ידי `C`)
- ביטול של cache line או cache  (מסומן על ידי `I`)

### ערכים מושפעים

בעת ביצוע פעולות תחזוקת cache, ניתן לבחור באילו ערכים הפעולה צריכה לחול:

- לכל הערכים (`All`): פעולה זו משפיעה על כל ה-cache במערכת. הבחירה ב-`All` אינה זמינה עבור data cache.

- לכתובת הוירטואלית (`VA`): פעולה זו מתבצעת על שורת ה-cache המכילה תוכן של כתובת וירטואלית ספציפית. כאן מתייחסים ל-cache על פי כתובת וירטואלית.

- ה-Set ו-Way: פעולה זו מתבצעת על cache line ספציפית שנבחרת לפי מיקומה בתוך מבנה ה-cache, כלומר לפי ה-Set וה-Way שלה.

### הגדרת נקודת ביצוע והיקף תחזוקת cache

ה-scope ביצוע הפעולה יכול להיות PoC או PoU.

#### Point of Unification

עשויות להתקיים מספר נקודות איחוד (PoU) במערכת:

1. **נקודת איחוד לכל ליבה:** כל ליבה במערכת עשויה להכיל נקודת איחוד משלה. בנקודה זו, כל הוראות הזיכרון ונתוני ה-cache הקשורים לליבה זו מאוחדים, כלומר, כל שינויים בזיכרון הנתונים או הוראות cache בליבה זו מתואמים ונראים כאחידים בליבה עצמה.

2. **נקודת איחוד למערכת כולה או לתחום שיתוף:** בנוסף, עשויה להתקיים נקודת איחוד ברמה גבוהה יותר, המתייחסת למערכת כולה או לתחום השיתוף הכולל. בנקודה זו, כל ה-cache-ים במערכת או בתחום השיתוף מאוחדים, כך שכל השינויים המתרחשים ב-cache הנתונים או הוראות ה-cache נראים כאחידים בכל המעבדים המשתפים את אותו תחום.

כאשר מתבצעת fetch מכתיבה, זה מרמז שהשינוי הגיע לנקודת האיחוד הקרובה ביותר (PoU), כלומר, כל השינויים נשמרים ומעודכנים עד לנקודה זו. עם זאת, זה לא מרמז שהשינוי הגיע לכל נקודת איחוד אחרת במערכת, גם אם הכתיבה בוצעה על ידי ליבה מרוחקת או מעבד אחר במערכת.

הכרת ה-PoU מאפשרת self modifying code  כדי להבטיח ש-fetch של הוראות עתידיות יבוצעו בצורה נכונה מהגרסה של הקוד שעבר את השינוי.
#### Point of Coherency

נקודות הקוהרנטיות (PoC) - היא הנקודה שבה עדכוני ה-cache נדחפים לזיכרון הפיזי. לכן כל הליבות, DSPs, התקני I/O, מנועי DMA וכו' כולם רואים את אותו עותק של זיכרון.

### סוג השיתוף
לפעולות שניתן לשדר, אתה יכול לבחור את רמת השיתוף:

- סוג השיתוף Inner Shareable מסומן על ידי `IS`



### ה-cache ברמת המערכת

מבחינה קונספטואלית, ניתן להבחין ב-2 קטגוריות עיקריות של cache-י מערכת ב-arm:

1. ה-cache-י מערכת לפני נקודת הקוהרנטיות הניתנים לניהול חלקי: cache-י מערכת אלה נמצאים לפני נקודת הקוהרנטיות וניתנים לניהול באמצעות הוראות תחזוקה של cache על פי כתובת וירטואלית החלות על נקודת הקוהרנטיות. עם זאת, הם אינם ניתנים לניהול על ידי הוראות תחזוקה לפי set/way. תחזוקה של cache-ים כאלה, כמו במקרה של ניהול צריכת חשמל, חייבת להתבצע באמצעות מנגנונים שאינם ארכיטקטוניים.

2. ה-cache-י מערכת מעבר לנקודת הקוהרנטיות: cache-ים אלה נמצאים מעבר לנקודת הקוהרנטיות ולכן אינם נגישים לתוכנה. ניהול cache-ים כאלה אינו נכלל בתחום הארכיטקטורה ונתון לניהול מחוץ למערכת הארכיטקטונית.

במערכת מרובת מעבדים, כאשר משתמשים בהוראת `IC IVAU` עבור מיקום non-cacheable, ההוראה משודרת לכל המעבדים בתוך התחום Inner Shareable של המעבד שמבצע את ההוראה. זאת למרות שמיקומי זיכרון רגילים שאינם נתמכים על ידי cache מטופלים כאל Outer Shared במצבים אחרים של הארכיטקטורה.

ייתכן שיידרשו צעדים נוספים בתוכנה כדי לסנכרן את פעולות המעבדים עם המעבדים האחרים. זה עשוי לכלול ביצוע הוראת ISB לאחר השלמת ביטול התוקף, על מנת למנוע בעיות הקשורות לשינויים וביצוע במקביל של רצפי הוראות.

בלוקים גדולים יותר של הוראות ניתן לשנות באמצעות הוראת `IC IALLU` במערכת חד-מעבד, או באמצעות `IC IALLUIS` במערכת מרובת מעבדים.

#### איפוס cache (Zero)

יכולת טעינת ה-cache מראש עם ערכי אפס באמצעות הוראת `DC ZVA` מאפשרת למעבדים לפעול בצורה הרבה יותר מהירה לעומת גישה למערכות זיכרון חיצוניות, שלעיתים יכולה לקחת הרבה זמן.

איפוס cache line מתבצע בצורה דומה לשליפה מוקדמת, בכך שמדובר בדרכים לרמוז למעבד על השימוש הצפוי בכתובות מסוימות בעתיד. עם זאת, פעולת האיפוס יכולה להיות מהירה יותר מכיוון שאין צורך להמתין להשלמת גישה לזיכרון חיצוני. במקום לקרוא את הנתונים מהזיכרון לתוך ה-cache, שורות ה-cache מתמלאות באפסים. זה מאפשר למעבד להבין שהקוד מחליף לחלוטין את תוכן שורת ה-cache, ולכן אין צורך בקריאה ראשונית.

דוגמה לשימוש: אם אתה זקוק ל-buffer אחסון זמני גדול או מאתחל מבנה חדש, תוכל לבחור בין כתיבת קוד שיתחיל להשתמש בזיכרון או קוד שיבצע טעינה מראש של הנתונים לפני השימוש. שני האפשרויות ידרשו זמן ומעבד לשימוש ברוחב פס זיכרון בקריאת התוכן הראשוני ל-cache. באמצעות אפס cache, תוכל לחסוך את רוחב הפס הנדרש ולבצע את הקוד מהר יותר.

## AMBA ACE/CHI

### מעבדים ותחזוקת cache

מעבדים משתמשים בטרנזקציות תחזוקת cache כדי לגשת ולתחזק את ה-cache-ים של מעבדים אחרים במערכת. טרנזקציות תחזוקה אלו מאפשרות למעבדים לראות את ההשפעה של פעולות load ו-store על cache מערכת שלא ניתן לגשת אליו בדרכים אחרות. 
טרנזקציות תחזוקת cache שידור יכולות להתפשט גם ל-cache-ים ב-downstream, מה שמאפשר תחזוקה של כל ה-cache-ים במערכת.

מעבד היוזם טרנזקציית תחזוקת cache אחראי גם לביצוע הפעולה המתאימה ב-cache המקומי שלו.

#### טרנזקציות תחזוקת cache

- טרנזקציית CleanShared מאפשרת למעבד לבצע פעולת ניקוי על ה-cache-ים של מעבדים אחרים במערכת. כאשר cache של מעבד שמחזיק cache line מלוכלכת מקבל טרנזקציית CleanShared, עליו לספק את שורת ה-cache כדי לכתוב אותה לזיכרון הראשי. ה-cache שמבצעים עליו snooping יכול לשמור את העותק המקומי שלו של שורת ה-cache.

- טרנזקציית CleanInvalid מאפשרת למעבד לבצע פעולת ניקוי וביטול תוקף על ה-cache-ים של מעבדים אחרים במערכת. כאשר cache שמחזיק cache line נקייה מקבל טרנזקציית CleanInvalid, עליו להסיר את העותק המקומי שלו של שורת ה-cache. אם ה-cache שמבצעים עליו snooping מחזיק cache line מלוכלכת, הוא נדרש לספק את שורת ה-cache כדי לכתוב אותה לזיכרון הראשי ולהסיר את העותק המקומי שלו.

- טרנזקציית MakeInvalid מאפשרת למעבד לבצע פעולת ביטול תוקף על ה-cache-ים של מעבדים אחרים במערכת. כאשר ה-cache שמבצעים עליו snooping מקבל טרנזקציית MakeInvalid, עליו להסיר את העותק המקומי שלו של שורת ה-cache, אך אינו נדרש לספק נתונים, גם אם שורת ה-cache מלוכלכת.


