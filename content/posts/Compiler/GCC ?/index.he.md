+++
authors = [ "Michael Shalitin",]
math = true
date = "2025-01-11"
tags = []
categories = []
series = []
title = "GCC ?"

+++










https://0xax.gitbooks.io/linux-insides/content/Theory/linux-theory-3.html
https://gcc.gnu.org/onlinedocs/gcc/Constraints.html
https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html
https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html


## אילוצים (Constraints) ל-Assembly inlines

אילוצים יכולים לומר אם אופרנד עשוי להיות ברגיסטר, ואיזה סוגים של רגיסטר; האם האופרנד יכול להיות הפניה לזיכרון, ואילו סוגי כתובת; האם האופרנד עשוי להיות קבוע מיידי, ואילו ערכים אפשריים עשויים להיות לו. אילוצים יכולים גם לדרוש שני אופרנדים כדי להתאים. תופעות לוואי אינן מותרות באופרנדים של inline asm, אלא אם נעשה שימוש באילוצים של `<` או `>` מכיוון שאין ערובה שתופעות הלוואי יתרחשו בדיוק פעם אחת בהוראה שיכולה לעדכן את רגיסטר הכתובות.


### סוגי אילוצים

#### m
האילוץ גורם ל-gcc להשתמש בזכרון של האופרנד, כלומר הוא מייצג אופרנד זיכרון.


#### r
אילוץ שמייצג רגיסטר



- אופרנדים המשתמשים במשנה האילוץ `+` נספרים כשני אופרנדים (כלומר, גם כקלט וגם כפלט) לקראת המקסימום הכולל של 30 אופרנדים לכל משפט asm.
- אילוץ `m` הוא אומר שהאופרד יפעל על זיכרון.





 
ה-`memory` היא סוג של clobber שאומר לקומפיילר שהקוד אסמבלי מבצע קריאת זיכרון או כתיבה לפריטים אחרים מאלה הרשומים באופרנדים של הקלט והפלט (לדוגמה, גישה לזיכרון שעליו מצביע אחד מפרמטרי הקלט). כדי להבטיח שהזיכרון מכיל ערכים נכונים, ייתכן ש-GCC יצטרך לשטוף (flush) ערכי רגיסטרים ספציפיים לזיכרון לפני ביצוע ה-ASM. יתר על כן, הקומפיילר אינו מניח שערכים כלשהם הנקראים מהזיכרון לפני ה- ASM נשארים ללא שינוי לאחר ה-ASM זה; זה טוען אותם מחדש לפי הצורך. השימוש ב"זיכרון" clobber יוצר למעשה מחסום זיכרון קריאה/כתיבה עבור הקומפיילר.

שימו לב שה-clobber הזה לא מונע מהמעבד לבצע קריאות ספקולטיביות מעבר להצהרת asm. כדי למנוע זאת, אתה צריך הוראות גדר ספציפיות למעבד.

הוא אומר לקומפיילר שהקוד אסמבלי מבצע קריאת זיכרון או כתיבה לפריטים אחרים מאלה הרשומים באופרנדים של הקלט והפלט (לדוגמה, גישה לזיכרון שעליו מצביע אחד מפרמטרי הקלט).


